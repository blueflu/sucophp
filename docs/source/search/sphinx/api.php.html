<!doctype html>

<html lang="en">
<head>

<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<meta name="generator" content="PHPDoctor 2.0.5 (http://peej.github.com/phpdoctor/)">
<meta name="when" content="Wed, 19 Feb 2014 01:42:36 +0000">

<link rel="stylesheet" type="text/css" href="../stylesheet.css">
<link rel="start" href="../overview-summary.html">

<title>Search\Sphinx\Api.php (SucoPHP API Doc)</title>

</head>
<body id="file" onload="parent.document.title=document.title;">

<div class="header">
<h1>SucoPHP Doc</h1>
<ul>
<li><a href="../overview-summary.html">Overview</a></li>
<li>Package</li><li>Class</li><li>Tree</li><li><a href="../overview-files.html">Files</a></li>
<li><a href="../deprecated-list.html">Deprecated</a></li>
<li><a href="../todo-list.html">Todo</a></li>
<li><a href="../index-all.html">Index</a></li>
</ul>
</div>

<div class="small_links">
<a href="../index.html" target="_top">Frames</a>
<a href="../source\search\sphinx\api.php.html" target="_top">No frames</a>
</div>
<hr>

<h1>Search\Sphinx\Api.php</h1>
<hr>

<a name="line1"></a><pre><?php
<a name="line2"></a>
<a name="line3"></a>//
<a name="line4"></a>// $Id: sphinxapi.php 3281 2012-07-08 20:45:52Z shodan $
<a name="line5"></a>//
<a name="line6"></a>
<a name="line7"></a>//
<a name="line8"></a>// Copyright (c) 2001-2012, Andrew Aksyonoff
<a name="line9"></a>// Copyright (c) 2008-2012, Sphinx Technologies Inc
<a name="line10"></a>// All rights reserved
<a name="line11"></a>//
<a name="line12"></a>// This program is free software; you can redistribute it and/or modify
<a name="line13"></a>// it under the terms of the GNU General Public License. You should have
<a name="line14"></a>// received a copy of the GPL license along with this program; if you
<a name="line15"></a>// did not, you can find it at http://www.gnu.org/
<a name="line16"></a>//
<a name="line17"></a>
<a name="line18"></a>/////////////////////////////////////////////////////////////////////////////
<a name="line19"></a>// PHP version of Sphinx searchd client (PHP API)
<a name="line20"></a>/////////////////////////////////////////////////////////////////////////////
<a name="line21"></a>
<a name="line22"></a>/// known searchd commands
<a name="line23"></a>define ( "SEARCHD_COMMAND_SEARCH",		0 );
<a name="line24"></a>define ( "SEARCHD_COMMAND_EXCERPT",		1 );
<a name="line25"></a>define ( "SEARCHD_COMMAND_UPDATE",		2 );
<a name="line26"></a>define ( "SEARCHD_COMMAND_KEYWORDS",	3 );
<a name="line27"></a>define ( "SEARCHD_COMMAND_PERSIST",		4 );
<a name="line28"></a>define ( "SEARCHD_COMMAND_STATUS",		5 );
<a name="line29"></a>define ( "SEARCHD_COMMAND_FLUSHATTRS",	7 );
<a name="line30"></a>
<a name="line31"></a>/// current client-side command implementation versions
<a name="line32"></a>define ( "VER_COMMAND_SEARCH",		0x119 );
<a name="line33"></a>define ( "VER_COMMAND_EXCERPT",		0x104 );
<a name="line34"></a>define ( "VER_COMMAND_UPDATE",		0x102 );
<a name="line35"></a>define ( "VER_COMMAND_KEYWORDS",	0x100 );
<a name="line36"></a>define ( "VER_COMMAND_STATUS",		0x100 );
<a name="line37"></a>define ( "VER_COMMAND_QUERY",		0x100 );
<a name="line38"></a>define ( "VER_COMMAND_FLUSHATTRS",	0x100 );
<a name="line39"></a>
<a name="line40"></a>/// known searchd status codes
<a name="line41"></a>define ( "SEARCHD_OK",				0 );
<a name="line42"></a>define ( "SEARCHD_ERROR",			1 );
<a name="line43"></a>define ( "SEARCHD_RETRY",			2 );
<a name="line44"></a>define ( "SEARCHD_WARNING",			3 );
<a name="line45"></a>
<a name="line46"></a>/// known match modes
<a name="line47"></a>define ( "SPH_MATCH_ALL",			0 );
<a name="line48"></a>define ( "SPH_MATCH_ANY",			1 );
<a name="line49"></a>define ( "SPH_MATCH_PHRASE",		2 );
<a name="line50"></a>define ( "SPH_MATCH_BOOLEAN",		3 );
<a name="line51"></a>define ( "SPH_MATCH_EXTENDED",		4 );
<a name="line52"></a>define ( "SPH_MATCH_FULLSCAN",		5 );
<a name="line53"></a>define ( "SPH_MATCH_EXTENDED2",		6 );	// extended engine V2 (TEMPORARY, WILL BE REMOVED)
<a name="line54"></a>
<a name="line55"></a>/// known ranking modes (ext2 only)
<a name="line56"></a>define ( "SPH_RANK_PROXIMITY_BM25",	0 );	///< default mode, phrase proximity major factor and BM25 minor one
<a name="line57"></a>define ( "SPH_RANK_BM25",			1 );	///< statistical mode, BM25 ranking only (faster but worse quality)
<a name="line58"></a>define ( "SPH_RANK_NONE",			2 );	///< no ranking, all matches get a weight of 1
<a name="line59"></a>define ( "SPH_RANK_WORDCOUNT",		3 );	///< simple word-count weighting, rank is a weighted sum of per-field keyword occurence counts
<a name="line60"></a>define ( "SPH_RANK_PROXIMITY",		4 );
<a name="line61"></a>define ( "SPH_RANK_MATCHANY",		5 );
<a name="line62"></a>define ( "SPH_RANK_FIELDMASK",		6 );
<a name="line63"></a>define ( "SPH_RANK_SPH04",			7 );
<a name="line64"></a>define ( "SPH_RANK_EXPR",			8 );
<a name="line65"></a>define ( "SPH_RANK_TOTAL",			9 );
<a name="line66"></a>
<a name="line67"></a>/// known sort modes
<a name="line68"></a>define ( "SPH_SORT_RELEVANCE",		0 );
<a name="line69"></a>define ( "SPH_SORT_ATTR_DESC",		1 );
<a name="line70"></a>define ( "SPH_SORT_ATTR_ASC",		2 );
<a name="line71"></a>define ( "SPH_SORT_TIME_SEGMENTS", 	3 );
<a name="line72"></a>define ( "SPH_SORT_EXTENDED", 		4 );
<a name="line73"></a>define ( "SPH_SORT_EXPR", 			5 );
<a name="line74"></a>
<a name="line75"></a>/// known filter types
<a name="line76"></a>define ( "SPH_FILTER_VALUES",		0 );
<a name="line77"></a>define ( "SPH_FILTER_RANGE",		1 );
<a name="line78"></a>define ( "SPH_FILTER_FLOATRANGE",	2 );
<a name="line79"></a>
<a name="line80"></a>/// known attribute types
<a name="line81"></a>define ( "SPH_ATTR_INTEGER",		1 );
<a name="line82"></a>define ( "SPH_ATTR_TIMESTAMP",		2 );
<a name="line83"></a>define ( "SPH_ATTR_ORDINAL",		3 );
<a name="line84"></a>define ( "SPH_ATTR_BOOL",			4 );
<a name="line85"></a>define ( "SPH_ATTR_FLOAT",			5 );
<a name="line86"></a>define ( "SPH_ATTR_BIGINT",			6 );
<a name="line87"></a>define ( "SPH_ATTR_STRING",			7 );
<a name="line88"></a>define ( "SPH_ATTR_MULTI",			0x40000001 );
<a name="line89"></a>define ( "SPH_ATTR_MULTI64",			0x40000002 );
<a name="line90"></a>
<a name="line91"></a>/// known grouping functions
<a name="line92"></a>define ( "SPH_GROUPBY_DAY",			0 );
<a name="line93"></a>define ( "SPH_GROUPBY_WEEK",		1 );
<a name="line94"></a>define ( "SPH_GROUPBY_MONTH",		2 );
<a name="line95"></a>define ( "SPH_GROUPBY_YEAR",		3 );
<a name="line96"></a>define ( "SPH_GROUPBY_ATTR",		4 );
<a name="line97"></a>define ( "SPH_GROUPBY_ATTRPAIR",	5 );
<a name="line98"></a>
<a name="line99"></a>// important properties of PHP's integers:
<a name="line100"></a>//  - always signed (one bit short of PHP_INT_SIZE)
<a name="line101"></a>//  - conversion from string to int is saturated
<a name="line102"></a>//  - float is double
<a name="line103"></a>//  - div converts arguments to floats
<a name="line104"></a>//  - mod converts arguments to ints
<a name="line105"></a>
<a name="line106"></a>// the packing code below works as follows:
<a name="line107"></a>//  - when we got an int, just pack it
<a name="line108"></a>//    if performance is a problem, this is the branch users should aim for
<a name="line109"></a>//
<a name="line110"></a>//  - otherwise, we got a number in string form
<a name="line111"></a>//    this might be due to different reasons, but we assume that this is
<a name="line112"></a>//    because it didn't fit into PHP int
<a name="line113"></a>//
<a name="line114"></a>//  - factor the string into high and low ints for packing
<a name="line115"></a>//    - if we have bcmath, then it is used
<a name="line116"></a>//    - if we don't, we have to do it manually (this is the fun part)
<a name="line117"></a>//
<a name="line118"></a>//    - x64 branch does factoring using ints
<a name="line119"></a>//    - x32 (ab)uses floats, since we can't fit unsigned 32-bit number into an int
<a name="line120"></a>//
<a name="line121"></a>// unpacking routines are pretty much the same.
<a name="line122"></a>//  - return ints if we can
<a name="line123"></a>//  - otherwise format number into a string
<a name="line124"></a>
<a name="line125"></a>/// pack 64-bit signed
<a name="line126"></a>function sphPackI64 ( $v )
<a name="line127"></a>{
<a name="line128"></a>	assert ( is_numeric($v) );
<a name="line129"></a>	
<a name="line130"></a>	// x64
<a name="line131"></a>	if ( PHP_INT_SIZE>=8 )
<a name="line132"></a>	{
<a name="line133"></a>		$v = (int)$v;
<a name="line134"></a>		return pack ( "NN", $v>>32, $v&0xFFFFFFFF );
<a name="line135"></a>	}
<a name="line136"></a>
<a name="line137"></a>	// x32, int
<a name="line138"></a>	if ( is_int($v) )
<a name="line139"></a>		return pack ( "NN", $v < 0 ? -1 : 0, $v );
<a name="line140"></a>
<a name="line141"></a>	// x32, bcmath	
<a name="line142"></a>	if ( function_exists("bcmul") )
<a name="line143"></a>	{
<a name="line144"></a>		if ( bccomp ( $v, 0 ) == -1 )
<a name="line145"></a>			$v = bcadd ( "18446744073709551616", $v );
<a name="line146"></a>		$h = bcdiv ( $v, "4294967296", 0 );
<a name="line147"></a>		$l = bcmod ( $v, "4294967296" );
<a name="line148"></a>		return pack ( "NN", (float)$h, (float)$l ); // conversion to float is intentional; int would lose 31st bit
<a name="line149"></a>	}
<a name="line150"></a>
<a name="line151"></a>	// x32, no-bcmath
<a name="line152"></a>	$p = max(0, strlen($v) - 13);
<a name="line153"></a>	$lo = abs((float)substr($v, $p));
<a name="line154"></a>	$hi = abs((float)substr($v, 0, $p));
<a name="line155"></a>
<a name="line156"></a>	$m = $lo + $hi*1316134912.0; // (10 ^ 13) % (1 << 32) = 1316134912
<a name="line157"></a>	$q = floor($m/4294967296.0);
<a name="line158"></a>	$l = $m - ($q*4294967296.0);
<a name="line159"></a>	$h = $hi*2328.0 + $q; // (10 ^ 13) / (1 << 32) = 2328
<a name="line160"></a>
<a name="line161"></a>	if ( $v<0 )
<a name="line162"></a>	{
<a name="line163"></a>		if ( $l==0 )
<a name="line164"></a>			$h = 4294967296.0 - $h;
<a name="line165"></a>		else
<a name="line166"></a>		{
<a name="line167"></a>			$h = 4294967295.0 - $h;
<a name="line168"></a>			$l = 4294967296.0 - $l;
<a name="line169"></a>		}
<a name="line170"></a>	}
<a name="line171"></a>	return pack ( "NN", $h, $l );
<a name="line172"></a>}
<a name="line173"></a>
<a name="line174"></a>/// pack 64-bit unsigned
<a name="line175"></a>function sphPackU64 ( $v )
<a name="line176"></a>{
<a name="line177"></a>	assert ( is_numeric($v) );
<a name="line178"></a>	
<a name="line179"></a>	// x64
<a name="line180"></a>	if ( PHP_INT_SIZE>=8 )
<a name="line181"></a>	{
<a name="line182"></a>		assert ( $v>=0 );
<a name="line183"></a>		
<a name="line184"></a>		// x64, int
<a name="line185"></a>		if ( is_int($v) )
<a name="line186"></a>			return pack ( "NN", $v>>32, $v&0xFFFFFFFF );
<a name="line187"></a>						  
<a name="line188"></a>		// x64, bcmath
<a name="line189"></a>		if ( function_exists("bcmul") )
<a name="line190"></a>		{
<a name="line191"></a>			$h = bcdiv ( $v, 4294967296, 0 );
<a name="line192"></a>			$l = bcmod ( $v, 4294967296 );
<a name="line193"></a>			return pack ( "NN", $h, $l );
<a name="line194"></a>		}
<a name="line195"></a>		
<a name="line196"></a>		// x64, no-bcmath
<a name="line197"></a>		$p = max ( 0, strlen($v) - 13 );
<a name="line198"></a>		$lo = (int)substr ( $v, $p );
<a name="line199"></a>		$hi = (int)substr ( $v, 0, $p );
<a name="line200"></a>	
<a name="line201"></a>		$m = $lo + $hi*1316134912;
<a name="line202"></a>		$l = $m % 4294967296;
<a name="line203"></a>		$h = $hi*2328 + (int)($m/4294967296);
<a name="line204"></a>
<a name="line205"></a>		return pack ( "NN", $h, $l );
<a name="line206"></a>	}
<a name="line207"></a>
<a name="line208"></a>	// x32, int
<a name="line209"></a>	if ( is_int($v) )
<a name="line210"></a>		return pack ( "NN", 0, $v );
<a name="line211"></a>	
<a name="line212"></a>	// x32, bcmath
<a name="line213"></a>	if ( function_exists("bcmul") )
<a name="line214"></a>	{
<a name="line215"></a>		$h = bcdiv ( $v, "4294967296", 0 );
<a name="line216"></a>		$l = bcmod ( $v, "4294967296" );
<a name="line217"></a>		return pack ( "NN", (float)$h, (float)$l ); // conversion to float is intentional; int would lose 31st bit
<a name="line218"></a>	}
<a name="line219"></a>
<a name="line220"></a>	// x32, no-bcmath
<a name="line221"></a>	$p = max(0, strlen($v) - 13);
<a name="line222"></a>	$lo = (float)substr($v, $p);
<a name="line223"></a>	$hi = (float)substr($v, 0, $p);
<a name="line224"></a>	
<a name="line225"></a>	$m = $lo + $hi*1316134912.0;
<a name="line226"></a>	$q = floor($m / 4294967296.0);
<a name="line227"></a>	$l = $m - ($q * 4294967296.0);
<a name="line228"></a>	$h = $hi*2328.0 + $q;
<a name="line229"></a>
<a name="line230"></a>	return pack ( "NN", $h, $l );
<a name="line231"></a>}
<a name="line232"></a>
<a name="line233"></a>// unpack 64-bit unsigned
<a name="line234"></a>function sphUnpackU64 ( $v )
<a name="line235"></a>{
<a name="line236"></a>	list ( $hi, $lo ) = array_values ( unpack ( "N*N*", $v ) );
<a name="line237"></a>
<a name="line238"></a>	if ( PHP_INT_SIZE>=8 )
<a name="line239"></a>	{
<a name="line240"></a>		if ( $hi<0 ) $hi += (1<<32); // because php 5.2.2 to 5.2.5 is totally fucked up again
<a name="line241"></a>		if ( $lo<0 ) $lo += (1<<32);
<a name="line242"></a>
<a name="line243"></a>		// x64, int
<a name="line244"></a>		if ( $hi<=2147483647 )
<a name="line245"></a>			return ($hi<<32) + $lo;
<a name="line246"></a>
<a name="line247"></a>		// x64, bcmath
<a name="line248"></a>		if ( function_exists("bcmul") )
<a name="line249"></a>			return bcadd ( $lo, bcmul ( $hi, "4294967296" ) );
<a name="line250"></a>
<a name="line251"></a>		// x64, no-bcmath
<a name="line252"></a>		$C = 100000;
<a name="line253"></a>		$h = ((int)($hi / $C) << 32) + (int)($lo / $C);
<a name="line254"></a>		$l = (($hi % $C) << 32) + ($lo % $C);
<a name="line255"></a>		if ( $l>$C )
<a name="line256"></a>		{
<a name="line257"></a>			$h += (int)($l / $C);
<a name="line258"></a>			$l  = $l % $C;
<a name="line259"></a>		}
<a name="line260"></a>
<a name="line261"></a>		if ( $h==0 )
<a name="line262"></a>			return $l;
<a name="line263"></a>		return sprintf ( "%d%05d", $h, $l );
<a name="line264"></a>	}
<a name="line265"></a>
<a name="line266"></a>	// x32, int
<a name="line267"></a>	if ( $hi==0 )
<a name="line268"></a>	{
<a name="line269"></a>		if ( $lo>0 )
<a name="line270"></a>			return $lo;
<a name="line271"></a>		return sprintf ( "%u", $lo );
<a name="line272"></a>	}
<a name="line273"></a>
<a name="line274"></a>	$hi = sprintf ( "%u", $hi );
<a name="line275"></a>	$lo = sprintf ( "%u", $lo );
<a name="line276"></a>
<a name="line277"></a>	// x32, bcmath
<a name="line278"></a>	if ( function_exists("bcmul") )
<a name="line279"></a>		return bcadd ( $lo, bcmul ( $hi, "4294967296" ) );
<a name="line280"></a>	
<a name="line281"></a>	// x32, no-bcmath
<a name="line282"></a>	$hi = (float)$hi;
<a name="line283"></a>	$lo = (float)$lo;
<a name="line284"></a>	
<a name="line285"></a>	$q = floor($hi/10000000.0);
<a name="line286"></a>	$r = $hi - $q*10000000.0;
<a name="line287"></a>	$m = $lo + $r*4967296.0;
<a name="line288"></a>	$mq = floor($m/10000000.0);
<a name="line289"></a>	$l = $m - $mq*10000000.0;
<a name="line290"></a>	$h = $q*4294967296.0 + $r*429.0 + $mq;
<a name="line291"></a>
<a name="line292"></a>	$h = sprintf ( "%.0f", $h );
<a name="line293"></a>	$l = sprintf ( "%07.0f", $l );
<a name="line294"></a>	if ( $h=="0" )
<a name="line295"></a>		return sprintf( "%.0f", (float)$l );
<a name="line296"></a>	return $h . $l;
<a name="line297"></a>}
<a name="line298"></a>
<a name="line299"></a>// unpack 64-bit signed
<a name="line300"></a>function sphUnpackI64 ( $v )
<a name="line301"></a>{
<a name="line302"></a>	list ( $hi, $lo ) = array_values ( unpack ( "N*N*", $v ) );
<a name="line303"></a>
<a name="line304"></a>	// x64
<a name="line305"></a>	if ( PHP_INT_SIZE>=8 )
<a name="line306"></a>	{
<a name="line307"></a>		if ( $hi<0 ) $hi += (1<<32); // because php 5.2.2 to 5.2.5 is totally fucked up again
<a name="line308"></a>		if ( $lo<0 ) $lo += (1<<32);
<a name="line309"></a>
<a name="line310"></a>		return ($hi<<32) + $lo;
<a name="line311"></a>	}
<a name="line312"></a>
<a name="line313"></a>	// x32, int
<a name="line314"></a>	if ( $hi==0 )
<a name="line315"></a>	{
<a name="line316"></a>		if ( $lo>0 )
<a name="line317"></a>			return $lo;
<a name="line318"></a>		return sprintf ( "%u", $lo );
<a name="line319"></a>	}
<a name="line320"></a>	// x32, int
<a name="line321"></a>	elseif ( $hi==-1 )
<a name="line322"></a>	{
<a name="line323"></a>		if ( $lo<0 )
<a name="line324"></a>			return $lo;
<a name="line325"></a>		return sprintf ( "%.0f", $lo - 4294967296.0 );
<a name="line326"></a>	}
<a name="line327"></a>	
<a name="line328"></a>	$neg = "";
<a name="line329"></a>	$c = 0;
<a name="line330"></a>	if ( $hi<0 )
<a name="line331"></a>	{
<a name="line332"></a>		$hi = ~$hi;
<a name="line333"></a>		$lo = ~$lo;
<a name="line334"></a>		$c = 1;
<a name="line335"></a>		$neg = "-";
<a name="line336"></a>	}	
<a name="line337"></a>
<a name="line338"></a>	$hi = sprintf ( "%u", $hi );
<a name="line339"></a>	$lo = sprintf ( "%u", $lo );
<a name="line340"></a>
<a name="line341"></a>	// x32, bcmath
<a name="line342"></a>	if ( function_exists("bcmul") )
<a name="line343"></a>		return $neg . bcadd ( bcadd ( $lo, bcmul ( $hi, "4294967296" ) ), $c );
<a name="line344"></a>
<a name="line345"></a>	// x32, no-bcmath
<a name="line346"></a>	$hi = (float)$hi;
<a name="line347"></a>	$lo = (float)$lo;
<a name="line348"></a>	
<a name="line349"></a>	$q = floor($hi/10000000.0);
<a name="line350"></a>	$r = $hi - $q*10000000.0;
<a name="line351"></a>	$m = $lo + $r*4967296.0;
<a name="line352"></a>	$mq = floor($m/10000000.0);
<a name="line353"></a>	$l = $m - $mq*10000000.0 + $c;
<a name="line354"></a>	$h = $q*4294967296.0 + $r*429.0 + $mq;
<a name="line355"></a>	if ( $l==10000000 )
<a name="line356"></a>	{
<a name="line357"></a>		$l = 0;
<a name="line358"></a>		$h += 1;
<a name="line359"></a>	}
<a name="line360"></a>
<a name="line361"></a>	$h = sprintf ( "%.0f", $h );
<a name="line362"></a>	$l = sprintf ( "%07.0f", $l );
<a name="line363"></a>	if ( $h=="0" )
<a name="line364"></a>		return $neg . sprintf( "%.0f", (float)$l );
<a name="line365"></a>	return $neg . $h . $l;
<a name="line366"></a>}
<a name="line367"></a>
<a name="line368"></a>
<a name="line369"></a>function sphFixUint ( $value )
<a name="line370"></a>{
<a name="line371"></a>	if ( PHP_INT_SIZE>=8 )
<a name="line372"></a>	{
<a name="line373"></a>		// x64 route, workaround broken unpack() in 5.2.2+
<a name="line374"></a>		if ( $value<0 ) $value += (1<<32);
<a name="line375"></a>		return $value;
<a name="line376"></a>	}
<a name="line377"></a>	else
<a name="line378"></a>	{
<a name="line379"></a>		// x32 route, workaround php signed/unsigned braindamage
<a name="line380"></a>		return sprintf ( "%u", $value );
<a name="line381"></a>	}
<a name="line382"></a>}
<a name="line383"></a>
<a name="line384"></a>
<a name="line385"></a>/// sphinx searchd client class
<a name="line386"></a>class SphinxClient
<a name="line387"></a>{
<a name="line388"></a>	var $_host;			///< searchd host (default is "localhost")
<a name="line389"></a>	var $_port;			///< searchd port (default is 9312)
<a name="line390"></a>	var $_offset;		///< how many records to seek from result-set start (default is 0)
<a name="line391"></a>	var $_limit;		///< how many records to return from result-set starting at offset (default is 20)
<a name="line392"></a>	var $_mode;			///< query matching mode (default is SPH_MATCH_ALL)
<a name="line393"></a>	var $_weights;		///< per-field weights (default is 1 for all fields)
<a name="line394"></a>	var $_sort;			///< match sorting mode (default is SPH_SORT_RELEVANCE)
<a name="line395"></a>	var $_sortby;		///< attribute to sort by (defualt is "")
<a name="line396"></a>	var $_min_id;		///< min ID to match (default is 0, which means no limit)
<a name="line397"></a>	var $_max_id;		///< max ID to match (default is 0, which means no limit)
<a name="line398"></a>	var $_filters;		///< search filters
<a name="line399"></a>	var $_groupby;		///< group-by attribute name
<a name="line400"></a>	var $_groupfunc;	///< group-by function (to pre-process group-by attribute value with)
<a name="line401"></a>	var $_groupsort;	///< group-by sorting clause (to sort groups in result set with)
<a name="line402"></a>	var $_groupdistinct;///< group-by count-distinct attribute
<a name="line403"></a>	var $_maxmatches;	///< max matches to retrieve
<a name="line404"></a>	var $_cutoff;		///< cutoff to stop searching at (default is 0)
<a name="line405"></a>	var $_retrycount;	///< distributed retries count
<a name="line406"></a>	var $_retrydelay;	///< distributed retries delay
<a name="line407"></a>	var $_anchor;		///< geographical anchor point
<a name="line408"></a>	var $_indexweights;	///< per-index weights
<a name="line409"></a>	var $_ranker;		///< ranking mode (default is SPH_RANK_PROXIMITY_BM25)
<a name="line410"></a>	var $_rankexpr;		///< ranking mode expression (for SPH_RANK_EXPR)
<a name="line411"></a>	var $_maxquerytime;	///< max query time, milliseconds (default is 0, do not limit)
<a name="line412"></a>	var $_fieldweights;	///< per-field-name weights
<a name="line413"></a>	var $_overrides;	///< per-query attribute values overrides
<a name="line414"></a>	var $_select;		///< select-list (attributes or expressions, with optional aliases)
<a name="line415"></a>
<a name="line416"></a>	var $_error;		///< last error message
<a name="line417"></a>	var $_warning;		///< last warning message
<a name="line418"></a>	var $_connerror;		///< connection error vs remote error flag
<a name="line419"></a>
<a name="line420"></a>	var $_reqs;			///< requests array for multi-query
<a name="line421"></a>	var $_mbenc;		///< stored mbstring encoding
<a name="line422"></a>	var $_arrayresult;	///< whether $result["matches"] should be a hash or an array
<a name="line423"></a>	var $_timeout;		///< connect timeout
<a name="line424"></a>
<a name="line425"></a>	/////////////////////////////////////////////////////////////////////////////
<a name="line426"></a>	// common stuff
<a name="line427"></a>	/////////////////////////////////////////////////////////////////////////////
<a name="line428"></a>
<a name="line429"></a>	/// create a new client object and fill defaults
<a name="line430"></a>	function SphinxClient ()
<a name="line431"></a>	{
<a name="line432"></a>		// per-client-object settings
<a name="line433"></a>		$this->_host		= "localhost";
<a name="line434"></a>		$this->_port		= 9312;
<a name="line435"></a>		$this->_path		= false;
<a name="line436"></a>		$this->_socket		= false;
<a name="line437"></a>
<a name="line438"></a>		// per-query settings
<a name="line439"></a>		$this->_offset		= 0;
<a name="line440"></a>		$this->_limit		= 20;
<a name="line441"></a>		$this->_mode		= SPH_MATCH_ALL;
<a name="line442"></a>		$this->_weights		= array ();
<a name="line443"></a>		$this->_sort		= SPH_SORT_RELEVANCE;
<a name="line444"></a>		$this->_sortby		= "";
<a name="line445"></a>		$this->_min_id		= 0;
<a name="line446"></a>		$this->_max_id		= 0;
<a name="line447"></a>		$this->_filters		= array ();
<a name="line448"></a>		$this->_groupby		= "";
<a name="line449"></a>		$this->_groupfunc	= SPH_GROUPBY_DAY;
<a name="line450"></a>		$this->_groupsort	= "@group desc";
<a name="line451"></a>		$this->_groupdistinct= "";
<a name="line452"></a>		$this->_maxmatches	= 1000;
<a name="line453"></a>		$this->_cutoff		= 0;
<a name="line454"></a>		$this->_retrycount	= 0;
<a name="line455"></a>		$this->_retrydelay	= 0;
<a name="line456"></a>		$this->_anchor		= array ();
<a name="line457"></a>		$this->_indexweights= array ();
<a name="line458"></a>		$this->_ranker		= SPH_RANK_PROXIMITY_BM25;
<a name="line459"></a>		$this->_rankexpr	= "";
<a name="line460"></a>		$this->_maxquerytime= 0;
<a name="line461"></a>		$this->_fieldweights= array();
<a name="line462"></a>		$this->_overrides 	= array();
<a name="line463"></a>		$this->_select		= "*";
<a name="line464"></a>
<a name="line465"></a>		$this->_error		= ""; // per-reply fields (for single-query case)
<a name="line466"></a>		$this->_warning		= "";
<a name="line467"></a>		$this->_connerror	= false;
<a name="line468"></a>
<a name="line469"></a>		$this->_reqs		= array ();	// requests storage (for multi-query case)
<a name="line470"></a>		$this->_mbenc		= "";
<a name="line471"></a>		$this->_arrayresult	= false;
<a name="line472"></a>		$this->_timeout		= 0;
<a name="line473"></a>	}
<a name="line474"></a>
<a name="line475"></a>	function __destruct()
<a name="line476"></a>	{
<a name="line477"></a>		if ( $this->_socket !== false )
<a name="line478"></a>			fclose ( $this->_socket );
<a name="line479"></a>	}
<a name="line480"></a>
<a name="line481"></a>	/// get last error message (string)
<a name="line482"></a>	function GetLastError ()
<a name="line483"></a>	{
<a name="line484"></a>		return $this->_error;
<a name="line485"></a>	}
<a name="line486"></a>
<a name="line487"></a>	/// get last warning message (string)
<a name="line488"></a>	function GetLastWarning ()
<a name="line489"></a>	{
<a name="line490"></a>		return $this->_warning;
<a name="line491"></a>	}
<a name="line492"></a>
<a name="line493"></a>	/// get last error flag (to tell network connection errors from searchd errors or broken responses)
<a name="line494"></a>	function IsConnectError()
<a name="line495"></a>	{
<a name="line496"></a>		return $this->_connerror;
<a name="line497"></a>	}
<a name="line498"></a>
<a name="line499"></a>	/// set searchd host name (string) and port (integer)
<a name="line500"></a>	function SetServer ( $host, $port = 0 )
<a name="line501"></a>	{
<a name="line502"></a>		assert ( is_string($host) );
<a name="line503"></a>		if ( $host[0] == '/')
<a name="line504"></a>		{
<a name="line505"></a>			$this->_path = 'unix://' . $host;
<a name="line506"></a>			return;
<a name="line507"></a>		}
<a name="line508"></a>		if ( substr ( $host, 0, 7 )=="unix://" )
<a name="line509"></a>		{
<a name="line510"></a>			$this->_path = $host;
<a name="line511"></a>			return;
<a name="line512"></a>		}
<a name="line513"></a>				
<a name="line514"></a>		$this->_host = $host;
<a name="line515"></a>		if ( is_int($port) )
<a name="line516"></a>			if ( $port )
<a name="line517"></a>				$this->_port = $port;
<a name="line518"></a>		$this->_path = '';
<a name="line519"></a>
<a name="line520"></a>	}
<a name="line521"></a>
<a name="line522"></a>	/// set server connection timeout (0 to remove)
<a name="line523"></a>	function SetConnectTimeout ( $timeout )
<a name="line524"></a>	{
<a name="line525"></a>		assert ( is_numeric($timeout) );
<a name="line526"></a>		$this->_timeout = $timeout;
<a name="line527"></a>	}
<a name="line528"></a>
<a name="line529"></a>
<a name="line530"></a>	function _Send ( $handle, $data, $length )
<a name="line531"></a>	{
<a name="line532"></a>		if ( feof($handle) || fwrite ( $handle, $data, $length ) !== $length )
<a name="line533"></a>		{
<a name="line534"></a>			$this->_error = 'connection unexpectedly closed (timed out?)';
<a name="line535"></a>			$this->_connerror = true;
<a name="line536"></a>			return false;
<a name="line537"></a>		}
<a name="line538"></a>		return true;
<a name="line539"></a>	}
<a name="line540"></a>
<a name="line541"></a>	/////////////////////////////////////////////////////////////////////////////
<a name="line542"></a>
<a name="line543"></a>	/// enter mbstring workaround mode
<a name="line544"></a>	function _MBPush ()
<a name="line545"></a>	{
<a name="line546"></a>		$this->_mbenc = "";
<a name="line547"></a>		if ( ini_get ( "mbstring.func_overload" ) & 2 )
<a name="line548"></a>		{
<a name="line549"></a>			$this->_mbenc = mb_internal_encoding();
<a name="line550"></a>			mb_internal_encoding ( "latin1" );
<a name="line551"></a>		}
<a name="line552"></a>    }
<a name="line553"></a>
<a name="line554"></a>	/// leave mbstring workaround mode
<a name="line555"></a>	function _MBPop ()
<a name="line556"></a>	{
<a name="line557"></a>		if ( $this->_mbenc )
<a name="line558"></a>			mb_internal_encoding ( $this->_mbenc );
<a name="line559"></a>	}
<a name="line560"></a>
<a name="line561"></a>	/// connect to searchd server
<a name="line562"></a>	function _Connect ()
<a name="line563"></a>	{
<a name="line564"></a>		if ( $this->_socket!==false )
<a name="line565"></a>		{
<a name="line566"></a>			// we are in persistent connection mode, so we have a socket
<a name="line567"></a>			// however, need to check whether it's still alive
<a name="line568"></a>			if ( !@feof ( $this->_socket ) )
<a name="line569"></a>				return $this->_socket;
<a name="line570"></a>
<a name="line571"></a>			// force reopen
<a name="line572"></a>			$this->_socket = false;
<a name="line573"></a>		}
<a name="line574"></a>
<a name="line575"></a>		$errno = 0;
<a name="line576"></a>		$errstr = "";
<a name="line577"></a>		$this->_connerror = false;
<a name="line578"></a>
<a name="line579"></a>		if ( $this->_path )
<a name="line580"></a>		{
<a name="line581"></a>			$host = $this->_path;
<a name="line582"></a>			$port = 0;
<a name="line583"></a>		}
<a name="line584"></a>		else
<a name="line585"></a>		{
<a name="line586"></a>			$host = $this->_host;
<a name="line587"></a>			$port = $this->_port;
<a name="line588"></a>		}
<a name="line589"></a>
<a name="line590"></a>		if ( $this->_timeout<=0 )
<a name="line591"></a>			$fp = @fsockopen ( $host, $port, $errno, $errstr );
<a name="line592"></a>		else
<a name="line593"></a>			$fp = @fsockopen ( $host, $port, $errno, $errstr, $this->_timeout );
<a name="line594"></a>		
<a name="line595"></a>		if ( !$fp )
<a name="line596"></a>		{
<a name="line597"></a>			if ( $this->_path )
<a name="line598"></a>				$location = $this->_path;
<a name="line599"></a>			else
<a name="line600"></a>				$location = "{$this->_host}:{$this->_port}";
<a name="line601"></a>			
<a name="line602"></a>			$errstr = trim ( $errstr );
<a name="line603"></a>			$this->_error = "connection to $location failed (errno=$errno, msg=$errstr)";
<a name="line604"></a>			$this->_connerror = true;
<a name="line605"></a>			return false;
<a name="line606"></a>		}
<a name="line607"></a>
<a name="line608"></a>		// send my version
<a name="line609"></a>		// this is a subtle part. we must do it before (!) reading back from searchd.
<a name="line610"></a>		// because otherwise under some conditions (reported on FreeBSD for instance)
<a name="line611"></a>		// TCP stack could throttle write-write-read pattern because of Nagle.
<a name="line612"></a>		if ( !$this->_Send ( $fp, pack ( "N", 1 ), 4 ) )
<a name="line613"></a>		{
<a name="line614"></a>			fclose ( $fp );
<a name="line615"></a>			$this->_error = "failed to send client protocol version";
<a name="line616"></a>			return false;
<a name="line617"></a>		}
<a name="line618"></a>
<a name="line619"></a>		// check version
<a name="line620"></a>		list(,$v) = unpack ( "N*", fread ( $fp, 4 ) );
<a name="line621"></a>		$v = (int)$v;
<a name="line622"></a>		if ( $v<1 )
<a name="line623"></a>		{
<a name="line624"></a>			fclose ( $fp );
<a name="line625"></a>			$this->_error = "expected searchd protocol version 1+, got version '$v'";
<a name="line626"></a>			return false;
<a name="line627"></a>		}
<a name="line628"></a>
<a name="line629"></a>		return $fp;
<a name="line630"></a>	}
<a name="line631"></a>
<a name="line632"></a>	/// get and check response packet from searchd server
<a name="line633"></a>	function _GetResponse ( $fp, $client_ver )
<a name="line634"></a>	{
<a name="line635"></a>		$response = "";
<a name="line636"></a>		$len = 0;
<a name="line637"></a>
<a name="line638"></a>		$header = fread ( $fp, 8 );
<a name="line639"></a>		if ( strlen($header)==8 )
<a name="line640"></a>		{
<a name="line641"></a>			list ( $status, $ver, $len ) = array_values ( unpack ( "n2a/Nb", $header ) );
<a name="line642"></a>			$left = $len;
<a name="line643"></a>			while ( $left>0 && !feof($fp) )
<a name="line644"></a>			{
<a name="line645"></a>				$chunk = fread ( $fp, min ( 8192, $left ) );
<a name="line646"></a>				if ( $chunk )
<a name="line647"></a>				{
<a name="line648"></a>					$response .= $chunk;
<a name="line649"></a>					$left -= strlen($chunk);
<a name="line650"></a>				}
<a name="line651"></a>			}
<a name="line652"></a>		}
<a name="line653"></a>		if ( $this->_socket === false )
<a name="line654"></a>			fclose ( $fp );
<a name="line655"></a>
<a name="line656"></a>		// check response
<a name="line657"></a>		$read = strlen ( $response );
<a name="line658"></a>		if ( !$response || $read!=$len )
<a name="line659"></a>		{
<a name="line660"></a>			$this->_error = $len
<a name="line661"></a>				? "failed to read searchd response (status=$status, ver=$ver, len=$len, read=$read)"
<a name="line662"></a>				: "received zero-sized searchd response";
<a name="line663"></a>			return false;
<a name="line664"></a>		}
<a name="line665"></a>
<a name="line666"></a>		// check status
<a name="line667"></a>		if ( $status==SEARCHD_WARNING )
<a name="line668"></a>		{
<a name="line669"></a>			list(,$wlen) = unpack ( "N*", substr ( $response, 0, 4 ) );
<a name="line670"></a>			$this->_warning = substr ( $response, 4, $wlen );
<a name="line671"></a>			return substr ( $response, 4+$wlen );
<a name="line672"></a>		}
<a name="line673"></a>		if ( $status==SEARCHD_ERROR )
<a name="line674"></a>		{
<a name="line675"></a>			$this->_error = "searchd error: " . substr ( $response, 4 );
<a name="line676"></a>			return false;
<a name="line677"></a>		}
<a name="line678"></a>		if ( $status==SEARCHD_RETRY )
<a name="line679"></a>		{
<a name="line680"></a>			$this->_error = "temporary searchd error: " . substr ( $response, 4 );
<a name="line681"></a>			return false;
<a name="line682"></a>		}
<a name="line683"></a>		if ( $status!=SEARCHD_OK )
<a name="line684"></a>		{
<a name="line685"></a>			$this->_error = "unknown status code '$status'";
<a name="line686"></a>			return false;
<a name="line687"></a>		}
<a name="line688"></a>
<a name="line689"></a>		// check version
<a name="line690"></a>		if ( $ver<$client_ver )
<a name="line691"></a>		{
<a name="line692"></a>			$this->_warning = sprintf ( "searchd command v.%d.%d older than client's v.%d.%d, some options might not work",
<a name="line693"></a>				$ver>>8, $ver&0xff, $client_ver>>8, $client_ver&0xff );
<a name="line694"></a>		}
<a name="line695"></a>
<a name="line696"></a>		return $response;
<a name="line697"></a>	}
<a name="line698"></a>
<a name="line699"></a>	/////////////////////////////////////////////////////////////////////////////
<a name="line700"></a>	// searching
<a name="line701"></a>	/////////////////////////////////////////////////////////////////////////////
<a name="line702"></a>
<a name="line703"></a>	/// set offset and count into result set,
<a name="line704"></a>	/// and optionally set max-matches and cutoff limits
<a name="line705"></a>	function SetLimits ( $offset, $limit, $max=0, $cutoff=0 )
<a name="line706"></a>	{
<a name="line707"></a>		assert ( is_int($offset) );
<a name="line708"></a>		assert ( is_int($limit) );
<a name="line709"></a>		assert ( $offset>=0 );
<a name="line710"></a>		assert ( $limit>0 );
<a name="line711"></a>		assert ( $max>=0 );
<a name="line712"></a>		$this->_offset = $offset;
<a name="line713"></a>		$this->_limit = $limit;
<a name="line714"></a>		if ( $max>0 )
<a name="line715"></a>			$this->_maxmatches = $max;
<a name="line716"></a>		if ( $cutoff>0 )
<a name="line717"></a>			$this->_cutoff = $cutoff;
<a name="line718"></a>	}
<a name="line719"></a>
<a name="line720"></a>	/// set maximum query time, in milliseconds, per-index
<a name="line721"></a>	/// integer, 0 means "do not limit"
<a name="line722"></a>	function SetMaxQueryTime ( $max )
<a name="line723"></a>	{
<a name="line724"></a>		assert ( is_int($max) );
<a name="line725"></a>		assert ( $max>=0 );
<a name="line726"></a>		$this->_maxquerytime = $max;
<a name="line727"></a>	}
<a name="line728"></a>
<a name="line729"></a>	/// set matching mode
<a name="line730"></a>	function SetMatchMode ( $mode )
<a name="line731"></a>	{
<a name="line732"></a>		assert ( $mode==SPH_MATCH_ALL
<a name="line733"></a>			|| $mode==SPH_MATCH_ANY
<a name="line734"></a>			|| $mode==SPH_MATCH_PHRASE
<a name="line735"></a>			|| $mode==SPH_MATCH_BOOLEAN
<a name="line736"></a>			|| $mode==SPH_MATCH_EXTENDED
<a name="line737"></a>			|| $mode==SPH_MATCH_FULLSCAN
<a name="line738"></a>			|| $mode==SPH_MATCH_EXTENDED2 );
<a name="line739"></a>		$this->_mode = $mode;
<a name="line740"></a>	}
<a name="line741"></a>
<a name="line742"></a>	/// set ranking mode
<a name="line743"></a>	function SetRankingMode ( $ranker, $rankexpr="" )
<a name="line744"></a>	{
<a name="line745"></a>		assert ( $ranker>=0 && $ranker<SPH_RANK_TOTAL );
<a name="line746"></a>		assert ( is_string($rankexpr) );
<a name="line747"></a>		$this->_ranker = $ranker;
<a name="line748"></a>		$this->_rankexpr = $rankexpr;
<a name="line749"></a>	}
<a name="line750"></a>
<a name="line751"></a>	/// set matches sorting mode
<a name="line752"></a>	function SetSortMode ( $mode, $sortby="" )
<a name="line753"></a>	{
<a name="line754"></a>		assert (
<a name="line755"></a>			$mode==SPH_SORT_RELEVANCE ||
<a name="line756"></a>			$mode==SPH_SORT_ATTR_DESC ||
<a name="line757"></a>			$mode==SPH_SORT_ATTR_ASC ||
<a name="line758"></a>			$mode==SPH_SORT_TIME_SEGMENTS ||
<a name="line759"></a>			$mode==SPH_SORT_EXTENDED ||
<a name="line760"></a>			$mode==SPH_SORT_EXPR );
<a name="line761"></a>		assert ( is_string($sortby) );
<a name="line762"></a>		assert ( $mode==SPH_SORT_RELEVANCE || strlen($sortby)>0 );
<a name="line763"></a>
<a name="line764"></a>		$this->_sort = $mode;
<a name="line765"></a>		$this->_sortby = $sortby;
<a name="line766"></a>	}
<a name="line767"></a>
<a name="line768"></a>	/// bind per-field weights by order
<a name="line769"></a>	/// DEPRECATED; use SetFieldWeights() instead
<a name="line770"></a>	function SetWeights ( $weights )
<a name="line771"></a>	{
<a name="line772"></a>		assert ( is_array($weights) );
<a name="line773"></a>		foreach ( $weights as $weight )
<a name="line774"></a>			assert ( is_int($weight) );
<a name="line775"></a>
<a name="line776"></a>		$this->_weights = $weights;
<a name="line777"></a>	}
<a name="line778"></a>
<a name="line779"></a>	/// bind per-field weights by name
<a name="line780"></a>	function SetFieldWeights ( $weights )
<a name="line781"></a>	{
<a name="line782"></a>		assert ( is_array($weights) );
<a name="line783"></a>		foreach ( $weights as $name=>$weight )
<a name="line784"></a>		{
<a name="line785"></a>			assert ( is_string($name) );
<a name="line786"></a>			assert ( is_int($weight) );
<a name="line787"></a>		}
<a name="line788"></a>		$this->_fieldweights = $weights;
<a name="line789"></a>	}
<a name="line790"></a>
<a name="line791"></a>	/// bind per-index weights by name
<a name="line792"></a>	function SetIndexWeights ( $weights )
<a name="line793"></a>	{
<a name="line794"></a>		assert ( is_array($weights) );
<a name="line795"></a>		foreach ( $weights as $index=>$weight )
<a name="line796"></a>		{
<a name="line797"></a>			assert ( is_string($index) );
<a name="line798"></a>			assert ( is_int($weight) );
<a name="line799"></a>		}
<a name="line800"></a>		$this->_indexweights = $weights;
<a name="line801"></a>	}
<a name="line802"></a>
<a name="line803"></a>	/// set IDs range to match
<a name="line804"></a>	/// only match records if document ID is beetwen $min and $max (inclusive)
<a name="line805"></a>	function SetIDRange ( $min, $max )
<a name="line806"></a>	{
<a name="line807"></a>		assert ( is_numeric($min) );
<a name="line808"></a>		assert ( is_numeric($max) );
<a name="line809"></a>		assert ( $min<=$max );
<a name="line810"></a>		$this->_min_id = $min;
<a name="line811"></a>		$this->_max_id = $max;
<a name="line812"></a>	}
<a name="line813"></a>
<a name="line814"></a>	/// set values set filter
<a name="line815"></a>	/// only match records where $attribute value is in given set
<a name="line816"></a>	function SetFilter ( $attribute, $values, $exclude=false )
<a name="line817"></a>	{
<a name="line818"></a>		assert ( is_string($attribute) );
<a name="line819"></a>		assert ( is_array($values) );
<a name="line820"></a>		assert ( count($values) );
<a name="line821"></a>
<a name="line822"></a>		if ( is_array($values) && count($values) )
<a name="line823"></a>		{
<a name="line824"></a>			foreach ( $values as $value )
<a name="line825"></a>				assert ( is_numeric($value) );
<a name="line826"></a>
<a name="line827"></a>			$this->_filters[] = array ( "type"=>SPH_FILTER_VALUES, "attr"=>$attribute, "exclude"=>$exclude, "values"=>$values );
<a name="line828"></a>		}
<a name="line829"></a>	}
<a name="line830"></a>
<a name="line831"></a>	/// set range filter
<a name="line832"></a>	/// only match records if $attribute value is beetwen $min and $max (inclusive)
<a name="line833"></a>	function SetFilterRange ( $attribute, $min, $max, $exclude=false )
<a name="line834"></a>	{
<a name="line835"></a>		assert ( is_string($attribute) );
<a name="line836"></a>		assert ( is_numeric($min) );
<a name="line837"></a>		assert ( is_numeric($max) );
<a name="line838"></a>		assert ( $min<=$max );
<a name="line839"></a>
<a name="line840"></a>		$this->_filters[] = array ( "type"=>SPH_FILTER_RANGE, "attr"=>$attribute, "exclude"=>$exclude, "min"=>$min, "max"=>$max );
<a name="line841"></a>	}
<a name="line842"></a>
<a name="line843"></a>	/// set float range filter
<a name="line844"></a>	/// only match records if $attribute value is beetwen $min and $max (inclusive)
<a name="line845"></a>	function SetFilterFloatRange ( $attribute, $min, $max, $exclude=false )
<a name="line846"></a>	{
<a name="line847"></a>		assert ( is_string($attribute) );
<a name="line848"></a>		assert ( is_float($min) );
<a name="line849"></a>		assert ( is_float($max) );
<a name="line850"></a>		assert ( $min<=$max );
<a name="line851"></a>
<a name="line852"></a>		$this->_filters[] = array ( "type"=>SPH_FILTER_FLOATRANGE, "attr"=>$attribute, "exclude"=>$exclude, "min"=>$min, "max"=>$max );
<a name="line853"></a>	}
<a name="line854"></a>
<a name="line855"></a>	/// setup anchor point for geosphere distance calculations
<a name="line856"></a>	/// required to use @geodist in filters and sorting
<a name="line857"></a>	/// latitude and longitude must be in radians
<a name="line858"></a>	function SetGeoAnchor ( $attrlat, $attrlong, $lat, $long )
<a name="line859"></a>	{
<a name="line860"></a>		assert ( is_string($attrlat) );
<a name="line861"></a>		assert ( is_string($attrlong) );
<a name="line862"></a>		assert ( is_float($lat) );
<a name="line863"></a>		assert ( is_float($long) );
<a name="line864"></a>
<a name="line865"></a>		$this->_anchor = array ( "attrlat"=>$attrlat, "attrlong"=>$attrlong, "lat"=>$lat, "long"=>$long );
<a name="line866"></a>	}
<a name="line867"></a>
<a name="line868"></a>	/// set grouping attribute and function
<a name="line869"></a>	function SetGroupBy ( $attribute, $func, $groupsort="@group desc" )
<a name="line870"></a>	{
<a name="line871"></a>		assert ( is_string($attribute) );
<a name="line872"></a>		assert ( is_string($groupsort) );
<a name="line873"></a>		assert ( $func==SPH_GROUPBY_DAY
<a name="line874"></a>			|| $func==SPH_GROUPBY_WEEK
<a name="line875"></a>			|| $func==SPH_GROUPBY_MONTH
<a name="line876"></a>			|| $func==SPH_GROUPBY_YEAR
<a name="line877"></a>			|| $func==SPH_GROUPBY_ATTR
<a name="line878"></a>			|| $func==SPH_GROUPBY_ATTRPAIR );
<a name="line879"></a>
<a name="line880"></a>		$this->_groupby = $attribute;
<a name="line881"></a>		$this->_groupfunc = $func;
<a name="line882"></a>		$this->_groupsort = $groupsort;
<a name="line883"></a>	}
<a name="line884"></a>
<a name="line885"></a>	/// set count-distinct attribute for group-by queries
<a name="line886"></a>	function SetGroupDistinct ( $attribute )
<a name="line887"></a>	{
<a name="line888"></a>		assert ( is_string($attribute) );
<a name="line889"></a>		$this->_groupdistinct = $attribute;
<a name="line890"></a>	}
<a name="line891"></a>
<a name="line892"></a>	/// set distributed retries count and delay
<a name="line893"></a>	function SetRetries ( $count, $delay=0 )
<a name="line894"></a>	{
<a name="line895"></a>		assert ( is_int($count) && $count>=0 );
<a name="line896"></a>		assert ( is_int($delay) && $delay>=0 );
<a name="line897"></a>		$this->_retrycount = $count;
<a name="line898"></a>		$this->_retrydelay = $delay;
<a name="line899"></a>	}
<a name="line900"></a>
<a name="line901"></a>	/// set result set format (hash or array; hash by default)
<a name="line902"></a>	/// PHP specific; needed for group-by-MVA result sets that may contain duplicate IDs
<a name="line903"></a>	function SetArrayResult ( $arrayresult )
<a name="line904"></a>	{
<a name="line905"></a>		assert ( is_bool($arrayresult) );
<a name="line906"></a>		$this->_arrayresult = $arrayresult;
<a name="line907"></a>	}
<a name="line908"></a>
<a name="line909"></a>	/// set attribute values override
<a name="line910"></a>	/// there can be only one override per attribute
<a name="line911"></a>	/// $values must be a hash that maps document IDs to attribute values
<a name="line912"></a>	function SetOverride ( $attrname, $attrtype, $values )
<a name="line913"></a>	{
<a name="line914"></a>		assert ( is_string ( $attrname ) );
<a name="line915"></a>		assert ( in_array ( $attrtype, array ( SPH_ATTR_INTEGER, SPH_ATTR_TIMESTAMP, SPH_ATTR_BOOL, SPH_ATTR_FLOAT, SPH_ATTR_BIGINT ) ) );
<a name="line916"></a>		assert ( is_array ( $values ) );
<a name="line917"></a>
<a name="line918"></a>		$this->_overrides[$attrname] = array ( "attr"=>$attrname, "type"=>$attrtype, "values"=>$values );
<a name="line919"></a>	}
<a name="line920"></a>
<a name="line921"></a>	/// set select-list (attributes or expressions), SQL-like syntax
<a name="line922"></a>	function SetSelect ( $select )
<a name="line923"></a>	{
<a name="line924"></a>		assert ( is_string ( $select ) );
<a name="line925"></a>		$this->_select = $select;
<a name="line926"></a>	}
<a name="line927"></a>
<a name="line928"></a>	//////////////////////////////////////////////////////////////////////////////
<a name="line929"></a>
<a name="line930"></a>	/// clear all filters (for multi-queries)
<a name="line931"></a>	function ResetFilters ()
<a name="line932"></a>	{
<a name="line933"></a>		$this->_filters = array();
<a name="line934"></a>		$this->_anchor = array();
<a name="line935"></a>	}
<a name="line936"></a>
<a name="line937"></a>	/// clear groupby settings (for multi-queries)
<a name="line938"></a>	function ResetGroupBy ()
<a name="line939"></a>	{
<a name="line940"></a>		$this->_groupby		= "";
<a name="line941"></a>		$this->_groupfunc	= SPH_GROUPBY_DAY;
<a name="line942"></a>		$this->_groupsort	= "@group desc";
<a name="line943"></a>		$this->_groupdistinct= "";
<a name="line944"></a>	}
<a name="line945"></a>
<a name="line946"></a>	/// clear all attribute value overrides (for multi-queries)
<a name="line947"></a>	function ResetOverrides ()
<a name="line948"></a>    {
<a name="line949"></a>    	$this->_overrides = array ();
<a name="line950"></a>    }
<a name="line951"></a>
<a name="line952"></a>	//////////////////////////////////////////////////////////////////////////////
<a name="line953"></a>
<a name="line954"></a>	/// connect to searchd server, run given search query through given indexes,
<a name="line955"></a>	/// and return the search results
<a name="line956"></a>	function Query ( $query, $index="*", $comment="" )
<a name="line957"></a>	{
<a name="line958"></a>		assert ( empty($this->_reqs) );
<a name="line959"></a>
<a name="line960"></a>		$this->AddQuery ( $query, $index, $comment );
<a name="line961"></a>		$results = $this->RunQueries ();
<a name="line962"></a>		$this->_reqs = array (); // just in case it failed too early
<a name="line963"></a>
<a name="line964"></a>		if ( !is_array($results) )
<a name="line965"></a>			return false; // probably network error; error message should be already filled
<a name="line966"></a>
<a name="line967"></a>		$this->_error = $results[0]["error"];
<a name="line968"></a>		$this->_warning = $results[0]["warning"];
<a name="line969"></a>		if ( $results[0]["status"]==SEARCHD_ERROR )
<a name="line970"></a>			return false;
<a name="line971"></a>		else
<a name="line972"></a>			return $results[0];
<a name="line973"></a>	}
<a name="line974"></a>
<a name="line975"></a>	/// helper to pack floats in network byte order
<a name="line976"></a>	function _PackFloat ( $f )
<a name="line977"></a>	{
<a name="line978"></a>		$t1 = pack ( "f", $f ); // machine order
<a name="line979"></a>		list(,$t2) = unpack ( "L*", $t1 ); // int in machine order
<a name="line980"></a>		return pack ( "N", $t2 );
<a name="line981"></a>	}
<a name="line982"></a>
<a name="line983"></a>	/// add query to multi-query batch
<a name="line984"></a>	/// returns index into results array from RunQueries() call
<a name="line985"></a>	function AddQuery ( $query, $index="*", $comment="" )
<a name="line986"></a>	{
<a name="line987"></a>		// mbstring workaround
<a name="line988"></a>		$this->_MBPush ();
<a name="line989"></a>
<a name="line990"></a>		// build request
<a name="line991"></a>		$req = pack ( "NNNN", $this->_offset, $this->_limit, $this->_mode, $this->_ranker );
<a name="line992"></a>		if ( $this->_ranker==SPH_RANK_EXPR )
<a name="line993"></a>			$req .= pack ( "N", strlen($this->_rankexpr) ) . $this->_rankexpr;
<a name="line994"></a>		$req .= pack ( "N", $this->_sort ); // (deprecated) sort mode
<a name="line995"></a>		$req .= pack ( "N", strlen($this->_sortby) ) . $this->_sortby;
<a name="line996"></a>		$req .= pack ( "N", strlen($query) ) . $query; // query itself
<a name="line997"></a>		$req .= pack ( "N", count($this->_weights) ); // weights
<a name="line998"></a>		foreach ( $this->_weights as $weight )
<a name="line999"></a>			$req .= pack ( "N", (int)$weight );
<a name="line1000"></a>		$req .= pack ( "N", strlen($index) ) . $index; // indexes
<a name="line1001"></a>		$req .= pack ( "N", 1 ); // id64 range marker
<a name="line1002"></a>		$req .= sphPackU64 ( $this->_min_id ) . sphPackU64 ( $this->_max_id ); // id64 range
<a name="line1003"></a>
<a name="line1004"></a>		// filters
<a name="line1005"></a>		$req .= pack ( "N", count($this->_filters) );
<a name="line1006"></a>		foreach ( $this->_filters as $filter )
<a name="line1007"></a>		{
<a name="line1008"></a>			$req .= pack ( "N", strlen($filter["attr"]) ) . $filter["attr"];
<a name="line1009"></a>			$req .= pack ( "N", $filter["type"] );
<a name="line1010"></a>			switch ( $filter["type"] )
<a name="line1011"></a>			{
<a name="line1012"></a>				case SPH_FILTER_VALUES:
<a name="line1013"></a>					$req .= pack ( "N", count($filter["values"]) );
<a name="line1014"></a>					foreach ( $filter["values"] as $value )
<a name="line1015"></a>						$req .= sphPackI64 ( $value );
<a name="line1016"></a>					break;
<a name="line1017"></a>
<a name="line1018"></a>				case SPH_FILTER_RANGE:
<a name="line1019"></a>					$req .= sphPackI64 ( $filter["min"] ) . sphPackI64 ( $filter["max"] );
<a name="line1020"></a>					break;
<a name="line1021"></a>
<a name="line1022"></a>				case SPH_FILTER_FLOATRANGE:
<a name="line1023"></a>					$req .= $this->_PackFloat ( $filter["min"] ) . $this->_PackFloat ( $filter["max"] );
<a name="line1024"></a>					break;
<a name="line1025"></a>
<a name="line1026"></a>				default:
<a name="line1027"></a>					assert ( 0 && "internal error: unhandled filter type" );
<a name="line1028"></a>			}
<a name="line1029"></a>			$req .= pack ( "N", $filter["exclude"] );
<a name="line1030"></a>		}
<a name="line1031"></a>
<a name="line1032"></a>		// group-by clause, max-matches count, group-sort clause, cutoff count
<a name="line1033"></a>		$req .= pack ( "NN", $this->_groupfunc, strlen($this->_groupby) ) . $this->_groupby;
<a name="line1034"></a>		$req .= pack ( "N", $this->_maxmatches );
<a name="line1035"></a>		$req .= pack ( "N", strlen($this->_groupsort) ) . $this->_groupsort;
<a name="line1036"></a>		$req .= pack ( "NNN", $this->_cutoff, $this->_retrycount, $this->_retrydelay );
<a name="line1037"></a>		$req .= pack ( "N", strlen($this->_groupdistinct) ) . $this->_groupdistinct;
<a name="line1038"></a>
<a name="line1039"></a>		// anchor point
<a name="line1040"></a>		if ( empty($this->_anchor) )
<a name="line1041"></a>		{
<a name="line1042"></a>			$req .= pack ( "N", 0 );
<a name="line1043"></a>		} else
<a name="line1044"></a>		{
<a name="line1045"></a>			$a =& $this->_anchor;
<a name="line1046"></a>			$req .= pack ( "N", 1 );
<a name="line1047"></a>			$req .= pack ( "N", strlen($a["attrlat"]) ) . $a["attrlat"];
<a name="line1048"></a>			$req .= pack ( "N", strlen($a["attrlong"]) ) . $a["attrlong"];
<a name="line1049"></a>			$req .= $this->_PackFloat ( $a["lat"] ) . $this->_PackFloat ( $a["long"] );
<a name="line1050"></a>		}
<a name="line1051"></a>
<a name="line1052"></a>		// per-index weights
<a name="line1053"></a>		$req .= pack ( "N", count($this->_indexweights) );
<a name="line1054"></a>		foreach ( $this->_indexweights as $idx=>$weight )
<a name="line1055"></a>			$req .= pack ( "N", strlen($idx) ) . $idx . pack ( "N", $weight );
<a name="line1056"></a>
<a name="line1057"></a>		// max query time
<a name="line1058"></a>		$req .= pack ( "N", $this->_maxquerytime );
<a name="line1059"></a>
<a name="line1060"></a>		// per-field weights
<a name="line1061"></a>		$req .= pack ( "N", count($this->_fieldweights) );
<a name="line1062"></a>		foreach ( $this->_fieldweights as $field=>$weight )
<a name="line1063"></a>			$req .= pack ( "N", strlen($field) ) . $field . pack ( "N", $weight );
<a name="line1064"></a>
<a name="line1065"></a>		// comment
<a name="line1066"></a>		$req .= pack ( "N", strlen($comment) ) . $comment;
<a name="line1067"></a>
<a name="line1068"></a>		// attribute overrides
<a name="line1069"></a>		$req .= pack ( "N", count($this->_overrides) );
<a name="line1070"></a>		foreach ( $this->_overrides as $key => $entry )
<a name="line1071"></a>		{
<a name="line1072"></a>			$req .= pack ( "N", strlen($entry["attr"]) ) . $entry["attr"];
<a name="line1073"></a>			$req .= pack ( "NN", $entry["type"], count($entry["values"]) );
<a name="line1074"></a>			foreach ( $entry["values"] as $id=>$val )
<a name="line1075"></a>			{
<a name="line1076"></a>				assert ( is_numeric($id) );
<a name="line1077"></a>				assert ( is_numeric($val) );
<a name="line1078"></a>
<a name="line1079"></a>				$req .= sphPackU64 ( $id );
<a name="line1080"></a>				switch ( $entry["type"] )
<a name="line1081"></a>				{
<a name="line1082"></a>					case SPH_ATTR_FLOAT:	$req .= $this->_PackFloat ( $val ); break;
<a name="line1083"></a>					case SPH_ATTR_BIGINT:	$req .= sphPackI64 ( $val ); break;
<a name="line1084"></a>					default:				$req .= pack ( "N", $val ); break;
<a name="line1085"></a>				}
<a name="line1086"></a>			}
<a name="line1087"></a>		}
<a name="line1088"></a>
<a name="line1089"></a>		// select-list
<a name="line1090"></a>		$req .= pack ( "N", strlen($this->_select) ) . $this->_select;
<a name="line1091"></a>
<a name="line1092"></a>		// mbstring workaround
<a name="line1093"></a>		$this->_MBPop ();
<a name="line1094"></a>
<a name="line1095"></a>		// store request to requests array
<a name="line1096"></a>		$this->_reqs[] = $req;
<a name="line1097"></a>		return count($this->_reqs)-1;
<a name="line1098"></a>	}
<a name="line1099"></a>
<a name="line1100"></a>	/// connect to searchd, run queries batch, and return an array of result sets
<a name="line1101"></a>	function RunQueries ()
<a name="line1102"></a>	{
<a name="line1103"></a>		if ( empty($this->_reqs) )
<a name="line1104"></a>		{
<a name="line1105"></a>			$this->_error = "no queries defined, issue AddQuery() first";
<a name="line1106"></a>			return false;
<a name="line1107"></a>		}
<a name="line1108"></a>
<a name="line1109"></a>		// mbstring workaround
<a name="line1110"></a>		$this->_MBPush ();
<a name="line1111"></a>
<a name="line1112"></a>		if (!( $fp = $this->_Connect() ))
<a name="line1113"></a>		{
<a name="line1114"></a>			$this->_MBPop ();
<a name="line1115"></a>			return false;
<a name="line1116"></a>		}
<a name="line1117"></a>
<a name="line1118"></a>		// send query, get response
<a name="line1119"></a>		$nreqs = count($this->_reqs);
<a name="line1120"></a>		$req = join ( "", $this->_reqs );
<a name="line1121"></a>		$len = 8+strlen($req);
<a name="line1122"></a>		$req = pack ( "nnNNN", SEARCHD_COMMAND_SEARCH, VER_COMMAND_SEARCH, $len, 0, $nreqs ) . $req; // add header
<a name="line1123"></a>
<a name="line1124"></a>		if ( !( $this->_Send ( $fp, $req, $len+8 ) ) ||
<a name="line1125"></a>			 !( $response = $this->_GetResponse ( $fp, VER_COMMAND_SEARCH ) ) )
<a name="line1126"></a>		{
<a name="line1127"></a>			$this->_MBPop ();
<a name="line1128"></a>			return false;
<a name="line1129"></a>		}
<a name="line1130"></a>
<a name="line1131"></a>		// query sent ok; we can reset reqs now
<a name="line1132"></a>		$this->_reqs = array ();
<a name="line1133"></a>
<a name="line1134"></a>		// parse and return response
<a name="line1135"></a>		return $this->_ParseSearchResponse ( $response, $nreqs );
<a name="line1136"></a>	}
<a name="line1137"></a>
<a name="line1138"></a>	/// parse and return search query (or queries) response
<a name="line1139"></a>	function _ParseSearchResponse ( $response, $nreqs )
<a name="line1140"></a>	{
<a name="line1141"></a>		$p = 0; // current position
<a name="line1142"></a>		$max = strlen($response); // max position for checks, to protect against broken responses
<a name="line1143"></a>
<a name="line1144"></a>		$results = array ();
<a name="line1145"></a>		for ( $ires=0; $ires<$nreqs && $p<$max; $ires++ )
<a name="line1146"></a>		{
<a name="line1147"></a>			$results[] = array();
<a name="line1148"></a>			$result =& $results[$ires];
<a name="line1149"></a>
<a name="line1150"></a>			$result["error"] = "";
<a name="line1151"></a>			$result["warning"] = "";
<a name="line1152"></a>
<a name="line1153"></a>			// extract status
<a name="line1154"></a>			list(,$status) = unpack ( "N*", substr ( $response, $p, 4 ) ); $p += 4;
<a name="line1155"></a>			$result["status"] = $status;
<a name="line1156"></a>			if ( $status!=SEARCHD_OK )
<a name="line1157"></a>			{
<a name="line1158"></a>				list(,$len) = unpack ( "N*", substr ( $response, $p, 4 ) ); $p += 4;
<a name="line1159"></a>				$message = substr ( $response, $p, $len ); $p += $len;
<a name="line1160"></a>
<a name="line1161"></a>				if ( $status==SEARCHD_WARNING )
<a name="line1162"></a>				{
<a name="line1163"></a>					$result["warning"] = $message;
<a name="line1164"></a>				} else
<a name="line1165"></a>				{
<a name="line1166"></a>					$result["error"] = $message;
<a name="line1167"></a>					continue;
<a name="line1168"></a>				}
<a name="line1169"></a>			}
<a name="line1170"></a>
<a name="line1171"></a>			// read schema
<a name="line1172"></a>			$fields = array ();
<a name="line1173"></a>			$attrs = array ();
<a name="line1174"></a>
<a name="line1175"></a>			list(,$nfields) = unpack ( "N*", substr ( $response, $p, 4 ) ); $p += 4;
<a name="line1176"></a>			while ( $nfields-->0 && $p<$max )
<a name="line1177"></a>			{
<a name="line1178"></a>				list(,$len) = unpack ( "N*", substr ( $response, $p, 4 ) ); $p += 4;
<a name="line1179"></a>				$fields[] = substr ( $response, $p, $len ); $p += $len;
<a name="line1180"></a>			}
<a name="line1181"></a>			$result["fields"] = $fields;
<a name="line1182"></a>
<a name="line1183"></a>			list(,$nattrs) = unpack ( "N*", substr ( $response, $p, 4 ) ); $p += 4;
<a name="line1184"></a>			while ( $nattrs-->0 && $p<$max  )
<a name="line1185"></a>			{
<a name="line1186"></a>				list(,$len) = unpack ( "N*", substr ( $response, $p, 4 ) ); $p += 4;
<a name="line1187"></a>				$attr = substr ( $response, $p, $len ); $p += $len;
<a name="line1188"></a>				list(,$type) = unpack ( "N*", substr ( $response, $p, 4 ) ); $p += 4;
<a name="line1189"></a>				$attrs[$attr] = $type;
<a name="line1190"></a>			}
<a name="line1191"></a>			$result["attrs"] = $attrs;
<a name="line1192"></a>
<a name="line1193"></a>			// read match count
<a name="line1194"></a>			list(,$count) = unpack ( "N*", substr ( $response, $p, 4 ) ); $p += 4;
<a name="line1195"></a>			list(,$id64) = unpack ( "N*", substr ( $response, $p, 4 ) ); $p += 4;
<a name="line1196"></a>
<a name="line1197"></a>			// read matches
<a name="line1198"></a>			$idx = -1;
<a name="line1199"></a>			while ( $count-->0 && $p<$max )
<a name="line1200"></a>			{
<a name="line1201"></a>				// index into result array
<a name="line1202"></a>				$idx++;
<a name="line1203"></a>
<a name="line1204"></a>				// parse document id and weight
<a name="line1205"></a>				if ( $id64 )
<a name="line1206"></a>				{
<a name="line1207"></a>					$doc = sphUnpackU64 ( substr ( $response, $p, 8 ) ); $p += 8;
<a name="line1208"></a>					list(,$weight) = unpack ( "N*", substr ( $response, $p, 4 ) ); $p += 4;
<a name="line1209"></a>				}
<a name="line1210"></a>				else
<a name="line1211"></a>				{
<a name="line1212"></a>					list ( $doc, $weight ) = array_values ( unpack ( "N*N*",
<a name="line1213"></a>						substr ( $response, $p, 8 ) ) );
<a name="line1214"></a>					$p += 8;
<a name="line1215"></a>					$doc = sphFixUint($doc);
<a name="line1216"></a>				}
<a name="line1217"></a>				$weight = sprintf ( "%u", $weight );
<a name="line1218"></a>
<a name="line1219"></a>				// create match entry
<a name="line1220"></a>				if ( $this->_arrayresult )
<a name="line1221"></a>					$result["matches"][$idx] = array ( "id"=>$doc, "weight"=>$weight );
<a name="line1222"></a>				else
<a name="line1223"></a>					$result["matches"][$doc]["weight"] = $weight;
<a name="line1224"></a>
<a name="line1225"></a>				// parse and create attributes
<a name="line1226"></a>				$attrvals = array ();
<a name="line1227"></a>				foreach ( $attrs as $attr=>$type )
<a name="line1228"></a>				{
<a name="line1229"></a>					// handle 64bit ints
<a name="line1230"></a>					if ( $type==SPH_ATTR_BIGINT )
<a name="line1231"></a>					{
<a name="line1232"></a>						$attrvals[$attr] = sphUnpackI64 ( substr ( $response, $p, 8 ) ); $p += 8;
<a name="line1233"></a>						continue;
<a name="line1234"></a>					}
<a name="line1235"></a>
<a name="line1236"></a>					// handle floats
<a name="line1237"></a>					if ( $type==SPH_ATTR_FLOAT )
<a name="line1238"></a>					{
<a name="line1239"></a>						list(,$uval) = unpack ( "N*", substr ( $response, $p, 4 ) ); $p += 4;
<a name="line1240"></a>						list(,$fval) = unpack ( "f*", pack ( "L", $uval ) ); 
<a name="line1241"></a>						$attrvals[$attr] = $fval;
<a name="line1242"></a>						continue;
<a name="line1243"></a>					}
<a name="line1244"></a>
<a name="line1245"></a>					// handle everything else as unsigned ints
<a name="line1246"></a>					list(,$val) = unpack ( "N*", substr ( $response, $p, 4 ) ); $p += 4;
<a name="line1247"></a>					if ( $type==SPH_ATTR_MULTI )
<a name="line1248"></a>					{
<a name="line1249"></a>						$attrvals[$attr] = array ();
<a name="line1250"></a>						$nvalues = $val;
<a name="line1251"></a>						while ( $nvalues-->0 && $p<$max )
<a name="line1252"></a>						{
<a name="line1253"></a>							list(,$val) = unpack ( "N*", substr ( $response, $p, 4 ) ); $p += 4;
<a name="line1254"></a>							$attrvals[$attr][] = sphFixUint($val);
<a name="line1255"></a>						}
<a name="line1256"></a>					} else if ( $type==SPH_ATTR_MULTI64 )
<a name="line1257"></a>					{
<a name="line1258"></a>						$attrvals[$attr] = array ();
<a name="line1259"></a>						$nvalues = $val;
<a name="line1260"></a>						while ( $nvalues>0 && $p<$max )
<a name="line1261"></a>						{
<a name="line1262"></a>							$attrvals[$attr][] = sphUnpackI64 ( substr ( $response, $p, 8 ) ); $p += 8;
<a name="line1263"></a>							$nvalues -= 2;
<a name="line1264"></a>						}
<a name="line1265"></a>					} else if ( $type==SPH_ATTR_STRING )
<a name="line1266"></a>					{
<a name="line1267"></a>						$attrvals[$attr] = substr ( $response, $p, $val );
<a name="line1268"></a>						$p += $val;						
<a name="line1269"></a>					} else
<a name="line1270"></a>					{
<a name="line1271"></a>						$attrvals[$attr] = sphFixUint($val);
<a name="line1272"></a>					}
<a name="line1273"></a>				}
<a name="line1274"></a>
<a name="line1275"></a>				if ( $this->_arrayresult )
<a name="line1276"></a>					$result["matches"][$idx]["attrs"] = $attrvals;
<a name="line1277"></a>				else
<a name="line1278"></a>					$result["matches"][$doc]["attrs"] = $attrvals;
<a name="line1279"></a>			}
<a name="line1280"></a>
<a name="line1281"></a>			list ( $total, $total_found, $msecs, $words ) =
<a name="line1282"></a>				array_values ( unpack ( "N*N*N*N*", substr ( $response, $p, 16 ) ) );
<a name="line1283"></a>			$result["total"] = sprintf ( "%u", $total );
<a name="line1284"></a>			$result["total_found"] = sprintf ( "%u", $total_found );
<a name="line1285"></a>			$result["time"] = sprintf ( "%.3f", $msecs/1000 );
<a name="line1286"></a>			$p += 16;
<a name="line1287"></a>
<a name="line1288"></a>			while ( $words-->0 && $p<$max )
<a name="line1289"></a>			{
<a name="line1290"></a>				list(,$len) = unpack ( "N*", substr ( $response, $p, 4 ) ); $p += 4;
<a name="line1291"></a>				$word = substr ( $response, $p, $len ); $p += $len;
<a name="line1292"></a>				list ( $docs, $hits ) = array_values ( unpack ( "N*N*", substr ( $response, $p, 8 ) ) ); $p += 8;
<a name="line1293"></a>				$result["words"][$word] = array (
<a name="line1294"></a>					"docs"=>sprintf ( "%u", $docs ),
<a name="line1295"></a>					"hits"=>sprintf ( "%u", $hits ) );
<a name="line1296"></a>			}
<a name="line1297"></a>		}
<a name="line1298"></a>
<a name="line1299"></a>		$this->_MBPop ();
<a name="line1300"></a>		return $results;
<a name="line1301"></a>	}
<a name="line1302"></a>
<a name="line1303"></a>	/////////////////////////////////////////////////////////////////////////////
<a name="line1304"></a>	// excerpts generation
<a name="line1305"></a>	/////////////////////////////////////////////////////////////////////////////
<a name="line1306"></a>
<a name="line1307"></a>	/// connect to searchd server, and generate exceprts (snippets)
<a name="line1308"></a>	/// of given documents for given query. returns false on failure,
<a name="line1309"></a>	/// an array of snippets on success
<a name="line1310"></a>	function BuildExcerpts ( $docs, $index, $words, $opts=array() )
<a name="line1311"></a>	{
<a name="line1312"></a>		assert ( is_array($docs) );
<a name="line1313"></a>		assert ( is_string($index) );
<a name="line1314"></a>		assert ( is_string($words) );
<a name="line1315"></a>		assert ( is_array($opts) );
<a name="line1316"></a>
<a name="line1317"></a>		$this->_MBPush ();
<a name="line1318"></a>
<a name="line1319"></a>		if (!( $fp = $this->_Connect() ))
<a name="line1320"></a>		{
<a name="line1321"></a>			$this->_MBPop();
<a name="line1322"></a>			return false;
<a name="line1323"></a>		}
<a name="line1324"></a>
<a name="line1325"></a>		/////////////////
<a name="line1326"></a>		// fixup options
<a name="line1327"></a>		/////////////////
<a name="line1328"></a>
<a name="line1329"></a>		if ( !isset($opts["before_match"]) )		$opts["before_match"] = "<b>";
<a name="line1330"></a>		if ( !isset($opts["after_match"]) )			$opts["after_match"] = "</b>";
<a name="line1331"></a>		if ( !isset($opts["chunk_separator"]) )		$opts["chunk_separator"] = " ... ";
<a name="line1332"></a>		if ( !isset($opts["limit"]) )				$opts["limit"] = 256;
<a name="line1333"></a>		if ( !isset($opts["limit_passages"]) )		$opts["limit_passages"] = 0;
<a name="line1334"></a>		if ( !isset($opts["limit_words"]) )			$opts["limit_words"] = 0;
<a name="line1335"></a>		if ( !isset($opts["around"]) )				$opts["around"] = 5;
<a name="line1336"></a>		if ( !isset($opts["exact_phrase"]) )		$opts["exact_phrase"] = false;
<a name="line1337"></a>		if ( !isset($opts["single_passage"]) )		$opts["single_passage"] = false;
<a name="line1338"></a>		if ( !isset($opts["use_boundaries"]) )		$opts["use_boundaries"] = false;
<a name="line1339"></a>		if ( !isset($opts["weight_order"]) )		$opts["weight_order"] = false;
<a name="line1340"></a>		if ( !isset($opts["query_mode"]) )			$opts["query_mode"] = false;
<a name="line1341"></a>		if ( !isset($opts["force_all_words"]) )		$opts["force_all_words"] = false;
<a name="line1342"></a>		if ( !isset($opts["start_passage_id"]) )	$opts["start_passage_id"] = 1;
<a name="line1343"></a>		if ( !isset($opts["load_files"]) )			$opts["load_files"] = false;
<a name="line1344"></a>		if ( !isset($opts["html_strip_mode"]) )		$opts["html_strip_mode"] = "index";
<a name="line1345"></a>		if ( !isset($opts["allow_empty"]) )			$opts["allow_empty"] = false;
<a name="line1346"></a>		if ( !isset($opts["passage_boundary"]) )	$opts["passage_boundary"] = "none";
<a name="line1347"></a>		if ( !isset($opts["emit_zones"]) )			$opts["emit_zones"] = false;
<a name="line1348"></a>		if ( !isset($opts["load_files_scattered"]) )		$opts["load_files_scattered"] = false;
<a name="line1349"></a>		
<a name="line1350"></a>
<a name="line1351"></a>		/////////////////
<a name="line1352"></a>		// build request
<a name="line1353"></a>		/////////////////
<a name="line1354"></a>
<a name="line1355"></a>		// v.1.2 req
<a name="line1356"></a>		$flags = 1; // remove spaces
<a name="line1357"></a>		if ( $opts["exact_phrase"] )	$flags |= 2;
<a name="line1358"></a>		if ( $opts["single_passage"] )	$flags |= 4;
<a name="line1359"></a>		if ( $opts["use_boundaries"] )	$flags |= 8;
<a name="line1360"></a>		if ( $opts["weight_order"] )	$flags |= 16;
<a name="line1361"></a>		if ( $opts["query_mode"] )		$flags |= 32;
<a name="line1362"></a>		if ( $opts["force_all_words"] )	$flags |= 64;
<a name="line1363"></a>		if ( $opts["load_files"] )		$flags |= 128;
<a name="line1364"></a>		if ( $opts["allow_empty"] )		$flags |= 256;
<a name="line1365"></a>		if ( $opts["emit_zones"] )		$flags |= 512;
<a name="line1366"></a>		if ( $opts["load_files_scattered"] )	$flags |= 1024;
<a name="line1367"></a>		$req = pack ( "NN", 0, $flags ); // mode=0, flags=$flags
<a name="line1368"></a>		$req .= pack ( "N", strlen($index) ) . $index; // req index
<a name="line1369"></a>		$req .= pack ( "N", strlen($words) ) . $words; // req words
<a name="line1370"></a>
<a name="line1371"></a>		// options
<a name="line1372"></a>		$req .= pack ( "N", strlen($opts["before_match"]) ) . $opts["before_match"];
<a name="line1373"></a>		$req .= pack ( "N", strlen($opts["after_match"]) ) . $opts["after_match"];
<a name="line1374"></a>		$req .= pack ( "N", strlen($opts["chunk_separator"]) ) . $opts["chunk_separator"];
<a name="line1375"></a>		$req .= pack ( "NN", (int)$opts["limit"], (int)$opts["around"] );
<a name="line1376"></a>		$req .= pack ( "NNN", (int)$opts["limit_passages"], (int)$opts["limit_words"], (int)$opts["start_passage_id"] ); // v.1.2
<a name="line1377"></a>		$req .= pack ( "N", strlen($opts["html_strip_mode"]) ) . $opts["html_strip_mode"];
<a name="line1378"></a>		$req .= pack ( "N", strlen($opts["passage_boundary"]) ) . $opts["passage_boundary"];
<a name="line1379"></a>
<a name="line1380"></a>		// documents
<a name="line1381"></a>		$req .= pack ( "N", count($docs) );
<a name="line1382"></a>		foreach ( $docs as $doc )
<a name="line1383"></a>		{
<a name="line1384"></a>			assert ( is_string($doc) );
<a name="line1385"></a>			$req .= pack ( "N", strlen($doc) ) . $doc;
<a name="line1386"></a>		}
<a name="line1387"></a>
<a name="line1388"></a>		////////////////////////////
<a name="line1389"></a>		// send query, get response
<a name="line1390"></a>		////////////////////////////
<a name="line1391"></a>
<a name="line1392"></a>		$len = strlen($req);
<a name="line1393"></a>		$req = pack ( "nnN", SEARCHD_COMMAND_EXCERPT, VER_COMMAND_EXCERPT, $len ) . $req; // add header
<a name="line1394"></a>		if ( !( $this->_Send ( $fp, $req, $len+8 ) ) ||
<a name="line1395"></a>			 !( $response = $this->_GetResponse ( $fp, VER_COMMAND_EXCERPT ) ) )
<a name="line1396"></a>		{
<a name="line1397"></a>			$this->_MBPop ();
<a name="line1398"></a>			return false;
<a name="line1399"></a>		}
<a name="line1400"></a>
<a name="line1401"></a>		//////////////////
<a name="line1402"></a>		// parse response
<a name="line1403"></a>		//////////////////
<a name="line1404"></a>
<a name="line1405"></a>		$pos = 0;
<a name="line1406"></a>		$res = array ();
<a name="line1407"></a>		$rlen = strlen($response);
<a name="line1408"></a>		for ( $i=0; $i<count($docs); $i++ )
<a name="line1409"></a>		{
<a name="line1410"></a>			list(,$len) = unpack ( "N*", substr ( $response, $pos, 4 ) );
<a name="line1411"></a>			$pos += 4;
<a name="line1412"></a>
<a name="line1413"></a>			if ( $pos+$len > $rlen )
<a name="line1414"></a>			{
<a name="line1415"></a>				$this->_error = "incomplete reply";
<a name="line1416"></a>				$this->_MBPop ();
<a name="line1417"></a>				return false;
<a name="line1418"></a>			}
<a name="line1419"></a>			$res[] = $len ? substr ( $response, $pos, $len ) : "";
<a name="line1420"></a>			$pos += $len;
<a name="line1421"></a>		}
<a name="line1422"></a>
<a name="line1423"></a>		$this->_MBPop ();
<a name="line1424"></a>		return $res;
<a name="line1425"></a>	}
<a name="line1426"></a>
<a name="line1427"></a>
<a name="line1428"></a>	/////////////////////////////////////////////////////////////////////////////
<a name="line1429"></a>	// keyword generation
<a name="line1430"></a>	/////////////////////////////////////////////////////////////////////////////
<a name="line1431"></a>
<a name="line1432"></a>	/// connect to searchd server, and generate keyword list for a given query
<a name="line1433"></a>	/// returns false on failure,
<a name="line1434"></a>	/// an array of words on success
<a name="line1435"></a>	function BuildKeywords ( $query, $index, $hits )
<a name="line1436"></a>	{
<a name="line1437"></a>		assert ( is_string($query) );
<a name="line1438"></a>		assert ( is_string($index) );
<a name="line1439"></a>		assert ( is_bool($hits) );
<a name="line1440"></a>
<a name="line1441"></a>		$this->_MBPush ();
<a name="line1442"></a>
<a name="line1443"></a>		if (!( $fp = $this->_Connect() ))
<a name="line1444"></a>		{
<a name="line1445"></a>			$this->_MBPop();
<a name="line1446"></a>			return false;
<a name="line1447"></a>		}
<a name="line1448"></a>
<a name="line1449"></a>		/////////////////
<a name="line1450"></a>		// build request
<a name="line1451"></a>		/////////////////
<a name="line1452"></a>
<a name="line1453"></a>		// v.1.0 req
<a name="line1454"></a>		$req  = pack ( "N", strlen($query) ) . $query; // req query
<a name="line1455"></a>		$req .= pack ( "N", strlen($index) ) . $index; // req index
<a name="line1456"></a>		$req .= pack ( "N", (int)$hits );
<a name="line1457"></a>
<a name="line1458"></a>		////////////////////////////
<a name="line1459"></a>		// send query, get response
<a name="line1460"></a>		////////////////////////////
<a name="line1461"></a>
<a name="line1462"></a>		$len = strlen($req);
<a name="line1463"></a>		$req = pack ( "nnN", SEARCHD_COMMAND_KEYWORDS, VER_COMMAND_KEYWORDS, $len ) . $req; // add header
<a name="line1464"></a>		if ( !( $this->_Send ( $fp, $req, $len+8 ) ) ||
<a name="line1465"></a>			 !( $response = $this->_GetResponse ( $fp, VER_COMMAND_KEYWORDS ) ) )
<a name="line1466"></a>		{
<a name="line1467"></a>			$this->_MBPop ();
<a name="line1468"></a>			return false;
<a name="line1469"></a>		}
<a name="line1470"></a>
<a name="line1471"></a>		//////////////////
<a name="line1472"></a>		// parse response
<a name="line1473"></a>		//////////////////
<a name="line1474"></a>
<a name="line1475"></a>		$pos = 0;
<a name="line1476"></a>		$res = array ();
<a name="line1477"></a>		$rlen = strlen($response);
<a name="line1478"></a>		list(,$nwords) = unpack ( "N*", substr ( $response, $pos, 4 ) );
<a name="line1479"></a>		$pos += 4;
<a name="line1480"></a>		for ( $i=0; $i<$nwords; $i++ )
<a name="line1481"></a>		{
<a name="line1482"></a>			list(,$len) = unpack ( "N*", substr ( $response, $pos, 4 ) );	$pos += 4;
<a name="line1483"></a>			$tokenized = $len ? substr ( $response, $pos, $len ) : "";
<a name="line1484"></a>			$pos += $len;
<a name="line1485"></a>
<a name="line1486"></a>			list(,$len) = unpack ( "N*", substr ( $response, $pos, 4 ) );	$pos += 4;
<a name="line1487"></a>			$normalized = $len ? substr ( $response, $pos, $len ) : "";
<a name="line1488"></a>			$pos += $len;
<a name="line1489"></a>
<a name="line1490"></a>			$res[] = array ( "tokenized"=>$tokenized, "normalized"=>$normalized );
<a name="line1491"></a>
<a name="line1492"></a>			if ( $hits )
<a name="line1493"></a>			{
<a name="line1494"></a>				list($ndocs,$nhits) = array_values ( unpack ( "N*N*", substr ( $response, $pos, 8 ) ) );
<a name="line1495"></a>				$pos += 8;
<a name="line1496"></a>				$res [$i]["docs"] = $ndocs;
<a name="line1497"></a>				$res [$i]["hits"] = $nhits;
<a name="line1498"></a>			}
<a name="line1499"></a>
<a name="line1500"></a>			if ( $pos > $rlen )
<a name="line1501"></a>			{
<a name="line1502"></a>				$this->_error = "incomplete reply";
<a name="line1503"></a>				$this->_MBPop ();
<a name="line1504"></a>				return false;
<a name="line1505"></a>			}
<a name="line1506"></a>		}
<a name="line1507"></a>
<a name="line1508"></a>		$this->_MBPop ();
<a name="line1509"></a>		return $res;
<a name="line1510"></a>	}
<a name="line1511"></a>
<a name="line1512"></a>	function EscapeString ( $string )
<a name="line1513"></a>	{
<a name="line1514"></a>		$from = array ( '\\', '(',')','|','-','!','@','~','"','&', '/', '^', '$', '=' );
<a name="line1515"></a>		$to   = array ( '\\\\', '\(','\)','\|','\-','\!','\@','\~','\"', '\&', '\/', '\^', '\$', '\=' );
<a name="line1516"></a>
<a name="line1517"></a>		return str_replace ( $from, $to, $string );
<a name="line1518"></a>	}
<a name="line1519"></a>
<a name="line1520"></a>	/////////////////////////////////////////////////////////////////////////////
<a name="line1521"></a>	// attribute updates
<a name="line1522"></a>	/////////////////////////////////////////////////////////////////////////////
<a name="line1523"></a>
<a name="line1524"></a>	/// batch update given attributes in given rows in given indexes
<a name="line1525"></a>	/// returns amount of updated documents (0 or more) on success, or -1 on failure
<a name="line1526"></a>	function UpdateAttributes ( $index, $attrs, $values, $mva=false )
<a name="line1527"></a>	{
<a name="line1528"></a>		// verify everything
<a name="line1529"></a>		assert ( is_string($index) );
<a name="line1530"></a>		assert ( is_bool($mva) );
<a name="line1531"></a>
<a name="line1532"></a>		assert ( is_array($attrs) );
<a name="line1533"></a>		foreach ( $attrs as $attr )
<a name="line1534"></a>			assert ( is_string($attr) );
<a name="line1535"></a>
<a name="line1536"></a>		assert ( is_array($values) );
<a name="line1537"></a>		foreach ( $values as $id=>$entry )
<a name="line1538"></a>		{
<a name="line1539"></a>			assert ( is_numeric($id) );
<a name="line1540"></a>			assert ( is_array($entry) );
<a name="line1541"></a>			assert ( count($entry)==count($attrs) );
<a name="line1542"></a>			foreach ( $entry as $v )
<a name="line1543"></a>			{
<a name="line1544"></a>				if ( $mva )
<a name="line1545"></a>				{
<a name="line1546"></a>					assert ( is_array($v) );
<a name="line1547"></a>					foreach ( $v as $vv )
<a name="line1548"></a>						assert ( is_int($vv) );
<a name="line1549"></a>				} else
<a name="line1550"></a>					assert ( is_int($v) );
<a name="line1551"></a>			}
<a name="line1552"></a>		}
<a name="line1553"></a>
<a name="line1554"></a>		// build request
<a name="line1555"></a>		$this->_MBPush ();
<a name="line1556"></a>		$req = pack ( "N", strlen($index) ) . $index;
<a name="line1557"></a>
<a name="line1558"></a>		$req .= pack ( "N", count($attrs) );
<a name="line1559"></a>		foreach ( $attrs as $attr )
<a name="line1560"></a>		{
<a name="line1561"></a>			$req .= pack ( "N", strlen($attr) ) . $attr;
<a name="line1562"></a>			$req .= pack ( "N", $mva ? 1 : 0 );
<a name="line1563"></a>		}
<a name="line1564"></a>
<a name="line1565"></a>		$req .= pack ( "N", count($values) );
<a name="line1566"></a>		foreach ( $values as $id=>$entry )
<a name="line1567"></a>		{
<a name="line1568"></a>			$req .= sphPackU64 ( $id );
<a name="line1569"></a>			foreach ( $entry as $v )
<a name="line1570"></a>			{
<a name="line1571"></a>				$req .= pack ( "N", $mva ? count($v) : $v );
<a name="line1572"></a>				if ( $mva )
<a name="line1573"></a>					foreach ( $v as $vv )
<a name="line1574"></a>						$req .= pack ( "N", $vv );
<a name="line1575"></a>			}
<a name="line1576"></a>		}
<a name="line1577"></a>
<a name="line1578"></a>		// connect, send query, get response
<a name="line1579"></a>		if (!( $fp = $this->_Connect() ))
<a name="line1580"></a>		{
<a name="line1581"></a>			$this->_MBPop ();
<a name="line1582"></a>			return -1;
<a name="line1583"></a>		}
<a name="line1584"></a>
<a name="line1585"></a>		$len = strlen($req);
<a name="line1586"></a>		$req = pack ( "nnN", SEARCHD_COMMAND_UPDATE, VER_COMMAND_UPDATE, $len ) . $req; // add header
<a name="line1587"></a>		if ( !$this->_Send ( $fp, $req, $len+8 ) )
<a name="line1588"></a>		{
<a name="line1589"></a>			$this->_MBPop ();
<a name="line1590"></a>			return -1;
<a name="line1591"></a>		}
<a name="line1592"></a>
<a name="line1593"></a>		if (!( $response = $this->_GetResponse ( $fp, VER_COMMAND_UPDATE ) ))
<a name="line1594"></a>		{
<a name="line1595"></a>			$this->_MBPop ();
<a name="line1596"></a>			return -1;
<a name="line1597"></a>		}
<a name="line1598"></a>
<a name="line1599"></a>		// parse response
<a name="line1600"></a>		list(,$updated) = unpack ( "N*", substr ( $response, 0, 4 ) );
<a name="line1601"></a>		$this->_MBPop ();
<a name="line1602"></a>		return $updated;
<a name="line1603"></a>	}
<a name="line1604"></a>
<a name="line1605"></a>	/////////////////////////////////////////////////////////////////////////////
<a name="line1606"></a>	// persistent connections
<a name="line1607"></a>	/////////////////////////////////////////////////////////////////////////////
<a name="line1608"></a>
<a name="line1609"></a>	function Open()
<a name="line1610"></a>	{
<a name="line1611"></a>		if ( $this->_socket !== false )
<a name="line1612"></a>		{
<a name="line1613"></a>			$this->_error = 'already connected';
<a name="line1614"></a>			return false;
<a name="line1615"></a>		}
<a name="line1616"></a>		if ( !$fp = $this->_Connect() )
<a name="line1617"></a>			return false;
<a name="line1618"></a>
<a name="line1619"></a>		// command, command version = 0, body length = 4, body = 1
<a name="line1620"></a>		$req = pack ( "nnNN", SEARCHD_COMMAND_PERSIST, 0, 4, 1 );
<a name="line1621"></a>		if ( !$this->_Send ( $fp, $req, 12 ) )
<a name="line1622"></a>			return false;
<a name="line1623"></a>
<a name="line1624"></a>		$this->_socket = $fp;
<a name="line1625"></a>		return true;
<a name="line1626"></a>	}
<a name="line1627"></a>
<a name="line1628"></a>	function Close()
<a name="line1629"></a>	{
<a name="line1630"></a>		if ( $this->_socket === false )
<a name="line1631"></a>		{
<a name="line1632"></a>			$this->_error = 'not connected';
<a name="line1633"></a>			return false;
<a name="line1634"></a>		}
<a name="line1635"></a>
<a name="line1636"></a>		fclose ( $this->_socket );
<a name="line1637"></a>		$this->_socket = false;
<a name="line1638"></a>		
<a name="line1639"></a>		return true;
<a name="line1640"></a>	}
<a name="line1641"></a>
<a name="line1642"></a>	//////////////////////////////////////////////////////////////////////////
<a name="line1643"></a>	// status
<a name="line1644"></a>	//////////////////////////////////////////////////////////////////////////
<a name="line1645"></a>
<a name="line1646"></a>	function Status ()
<a name="line1647"></a>	{
<a name="line1648"></a>		$this->_MBPush ();
<a name="line1649"></a>		if (!( $fp = $this->_Connect() ))
<a name="line1650"></a>		{
<a name="line1651"></a>			$this->_MBPop();
<a name="line1652"></a>			return false;
<a name="line1653"></a>		}
<a name="line1654"></a>
<a name="line1655"></a>		$req = pack ( "nnNN", SEARCHD_COMMAND_STATUS, VER_COMMAND_STATUS, 4, 1 ); // len=4, body=1
<a name="line1656"></a>		if ( !( $this->_Send ( $fp, $req, 12 ) ) ||
<a name="line1657"></a>			 !( $response = $this->_GetResponse ( $fp, VER_COMMAND_STATUS ) ) )
<a name="line1658"></a>		{
<a name="line1659"></a>			$this->_MBPop ();
<a name="line1660"></a>			return false;
<a name="line1661"></a>		}
<a name="line1662"></a>
<a name="line1663"></a>		$res = substr ( $response, 4 ); // just ignore length, error handling, etc
<a name="line1664"></a>		$p = 0;
<a name="line1665"></a>		list ( $rows, $cols ) = array_values ( unpack ( "N*N*", substr ( $response, $p, 8 ) ) ); $p += 8;
<a name="line1666"></a>
<a name="line1667"></a>		$res = array();
<a name="line1668"></a>		for ( $i=0; $i<$rows; $i++ )
<a name="line1669"></a>			for ( $j=0; $j<$cols; $j++ )
<a name="line1670"></a>		{
<a name="line1671"></a>			list(,$len) = unpack ( "N*", substr ( $response, $p, 4 ) ); $p += 4;
<a name="line1672"></a>			$res[$i][] = substr ( $response, $p, $len ); $p += $len;
<a name="line1673"></a>		}
<a name="line1674"></a>
<a name="line1675"></a>		$this->_MBPop ();
<a name="line1676"></a>		return $res;
<a name="line1677"></a>	}
<a name="line1678"></a>
<a name="line1679"></a>	//////////////////////////////////////////////////////////////////////////
<a name="line1680"></a>	// flush
<a name="line1681"></a>	//////////////////////////////////////////////////////////////////////////
<a name="line1682"></a>
<a name="line1683"></a>	function FlushAttributes ()
<a name="line1684"></a>	{
<a name="line1685"></a>		$this->_MBPush ();
<a name="line1686"></a>		if (!( $fp = $this->_Connect() ))
<a name="line1687"></a>		{
<a name="line1688"></a>			$this->_MBPop();
<a name="line1689"></a>			return -1;
<a name="line1690"></a>		}
<a name="line1691"></a>
<a name="line1692"></a>		$req = pack ( "nnN", SEARCHD_COMMAND_FLUSHATTRS, VER_COMMAND_FLUSHATTRS, 0 ); // len=0
<a name="line1693"></a>		if ( !( $this->_Send ( $fp, $req, 8 ) ) ||
<a name="line1694"></a>			 !( $response = $this->_GetResponse ( $fp, VER_COMMAND_FLUSHATTRS ) ) )
<a name="line1695"></a>		{
<a name="line1696"></a>			$this->_MBPop ();
<a name="line1697"></a>			return -1;
<a name="line1698"></a>		}
<a name="line1699"></a>
<a name="line1700"></a>		$tag = -1;
<a name="line1701"></a>		if ( strlen($response)==4 )
<a name="line1702"></a>			list(,$tag) = unpack ( "N*", $response );
<a name="line1703"></a>		else
<a name="line1704"></a>			$this->_error = "unexpected response length";
<a name="line1705"></a>
<a name="line1706"></a>		$this->_MBPop ();
<a name="line1707"></a>		return $tag;
<a name="line1708"></a>	}
<a name="line1709"></a>}
<a name="line1710"></a>
<a name="line1711"></a>//
<a name="line1712"></a>// $Id: sphinxapi.php 3281 2012-07-08 20:45:52Z shodan $
<a name="line1713"></a>//
<a name="line1714"></a></pre>
<div class="header">
<h1>SucoPHP Doc</h1>
<ul>
<li><a href="../overview-summary.html">Overview</a></li>
<li>Package</li><li>Class</li><li>Tree</li><li><a href="../overview-files.html">Files</a></li>
<li><a href="../deprecated-list.html">Deprecated</a></li>
<li><a href="../todo-list.html">Todo</a></li>
<li><a href="../index-all.html">Index</a></li>
</ul>
</div>

<div class="small_links">
<a href="../index.html" target="_top">Frames</a>
<a href="../source\search\sphinx\api.php.html" target="_top">No frames</a>
</div>
<hr>

<p id="footer">This document was generated by <a href="http://peej.github.com/phpdoctor/">PHPDoctor: The PHP Documentation Creator</a></p>

</body>

</html>